using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Unity.VisualScripting
{
    public sealed class Sidebar
    {
        public Sidebar(Sidebars sidebars, SidebarAnchor anchor)
        {
            this.sidebars = sidebars;
            this.anchor = anchor;

            e = new EventWrapper(this);
        }

        [DoNotSerialize]
        private Sidebars sidebars { get; }

        [DoNotSerialize]
        private SidebarAnchor anchor { get; }

        [DoNotSerialize]
        private EventWrapper e { get; }

        [DoNotSerialize]
        public bool show => displayedPanels.Count > 0;

        [DoNotSerialize]
        private bool isResizing;

        [Serialize]
        private float size { get; set; } = 300;

        [Serialize]
        private Vector2 scroll;

        [DoNotSerialize]
        public readonly List<SidebarPanel> displayedPanels = new List<SidebarPanel>();

        public void DrawLayout()
        {
            CacheDisplayedPanels();

            if (!show)
            {
                return;
            }

            var position = GUILayoutUtility.GetRect(GUIContent.none, GUIStyle.none, GUILayout.Width(GetWidth()), GUILayout.ExpandHeight(true));

            if (!e.IsLayout && !Event.current.ShouldSkip())
            {
                OnGUI(position);
            }
        }

        public void Remove<T>() where T : ISidebarPanelContent
        {
            foreach (var panel in displayedPanels.Where(p => p.content is T))
            {
                panel.Disable();
            }
        }

        private void CacheDisplayedPanels()
        {
            displayedPanels.Clear();
            displayedPanels.AddRange(sidebars.panels.Where(p => p.enabled && p.anchor == anchor).OrderBy(p => p.order));
        }

        public float GetWidth()
        {
            foreach (var panel in displayedPanels)
            {
                size = Mathf.Max(size, panel.content.minSize.x);
            }

            return size;
        }

        private float GetHeight(float totalHeight)
        {
            var height = 0f;

            for (int i = 0; i < displayedPanels.Count; i++)
            {
                var panel = displayedPanels[i];
                var isLast = i == displayedPanels.Count - 1;

                var minPanelHeight = panel.content.minSize.y;
                panel.height = Mathf.Max(panel.height, minPanelHeight);

                var panelHeight = panel.height;

                if (isLast && height < totalHeight)
                {
                    var remainingHeight = totalHeight - height - 1;
                    panelHeight = Mathf.Max(remainingHeight, minPanelHeight);
                }

                height += panelHeight;

                height++; // Separator
            }

            return height;
        }

        public void OnGUI(Rect position)
        {
            HandleResizing(position);

            if (Event.current.ShouldSkip(position))
            {
                return;
            }

            if (e.IsRepaint)
            {
                Styles.background.Draw(position, false, false, false, false);
            }

            if (anchor == SidebarAnchor.Left)
            {
                // leave space for scrolling after the potential scrollbar
                position.width -= Styles.resizeGrip;
            }

            LudiqGUIUtility.BeginScrollablePanel(position, width => GetHeight(position.height), out Rect sidebarScrolledPosition, ref scroll);

            var y = sidebarScrolledPosition.y;

            for (int i = 0; i < displayedPanels.Count; i++)
            {
                var panel = displayedPanels[i];
                var isLast = i == displayedPanels.Count - 1;

                if (isLast)
                {
                    var remainingHeight = sidebarScrolledPosition.height - y - 1;
                    var minPanelHeight = panel.content.minSize.y;
                    var heightOverride = Mathf.Max(remainingHeight, minPanelHeight);
                    panel.OnGUI(sidebarScrolledPosition, ref y, heightOverride);
                }
                else
                {
                    panel.OnGUI(sidebarScrolledPosition, ref y);
                }

                if (e.IsRepaint)
                {
                    Styles.separator.Draw(sidebarScrolledPosition.VerticalSection(ref y, 1), false, false, false, false);
                }
            }

            LudiqGUIUtility.EndScrollablePanel();

            if (e.IsRepaint)
            {
                Styles.separator.Draw(new Rect(position.x, position.y, 1, position.height), false, false, false, false);
            }
        }

        private void HandleResizing(Rect position)
        {
            Rect resizeArea;

            switch (anchor)
            {
                case SidebarAnchor.Left:
                    resizeArea = new Rect
                        (
                        position.xMax - Styles.resizeGrip,
                        position.y,
                        Styles.resizeGrip,
                        position.height
                        );
                    break;

                case SidebarAnchor.Right:
                    resizeArea = new Rect
                        (
                        position.x,
                        position.y,
                        Styles.resizeGrip,
                        position.height
                        );
                    break;

                default:
                    throw new UnexpectedEnumValueException<SidebarAnchor>(anchor);
            }

            EditorGUIUtility.AddCursorRect(resizeArea, MouseCursor.SplitResizeLeftRight);

            e.HandleCapture(resizeArea.Contains(e.mousePosition), false);

            if (e.IsMouseDown(MouseButton.Left) && resizeArea.Contains(e.mousePosition))
            {
                isResizing = true;
            }

            if (isResizing && e.IsMouseUp(MouseButton.Left))
            {
                isResizing = false;
            }

            if (isResizing && e.IsMouseDrag(MouseButton.Left))
            {
                switch (anchor)
                {
                    case SidebarAnchor.Left:
                        size = e.mousePosition.x - position.xMin;
                        break;

                    case SidebarAnchor.Right:
                        size = position.xMax - e.mousePosition.x;
                        break;

                    default:
                        throw new UnexpectedEnumValueException<SidebarAnchor>(anchor);
                }
            }

            e.HandleRelease();
        }

        public void OrderSpinner(Rect position, SidebarPanel panel)
        {
            Ensure.That(nameof(panel)).IsNotNull(panel);

            EditorGUIUtility.AddCursorRect(position, MouseCursor.Arrow);

            var isFirst = displayedPanels.FirstOrDefault() == panel;
            var isLast = displayedPanels.LastOrDefault() == panel;

            var orderIncrement = -LudiqGUI.Spinner(position, !isFirst, !isLast);

            if (orderIncrement == 0)
            {
                return;
            }

            if (orderIncrement == +1)
            {
                foreach (var otherPanel in displayedPanels)
                {
                    if (otherPanel != panel && otherPanel.order >= panel.order)
                    {
                        panel.order = otherPanel.order;
                        otherPanel.order--;
                        break;
                    }
                }
            }
            else if (orderIncrement == -1)
            {
                foreach (var otherPanel in displayedPanels)
                {
                    if (otherPanel != panel && otherPanel.order <= panel.order)
                    {
                        panel.order = otherPanel.order;
                        otherPanel.order++;
                        break;
                    }
                }
            }

            CacheDisplayedPanels();
        }

        private static class Styles
        {
            public static readonly GUIStyle background;
            public static readonly GUIStyle separator;
            public static readonly float resizeGrip = 2f;

            static Styles()
            {
                background = ColorPalette.unityBackgroundMid.CreateBackground();
                separator = ColorPalette.unityBackgroundDark.CreateBackground();
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     INDX( 	 ¯:Q           (   ğ  è         s                   >‡    € p     ½“    ¢~‘çìÙĞ±âù¯ÙM
çìÙ3rË$èìÙ0      0               I S i d e b a r P a n e l C o n t e n t . c s ¿“     z     ½“    bGtWÀìÙ P›î‚¤Ù ‡ÀäÙotWÀìÙø       ó                I S i d e b a r P a n e l C o n t e n t . c s . m e t a       À“    h V     ½“    ³ªtWÀìÙ P›î‚¤Ù<î‡ÀäÙ¹ÑtWÀìÙ 0      k!              
 S i d e b a r . c s   Á“    p `     ½“    ³&uWÀìÙ P›î‚¤Ù=C‡ÀäÙ‚9uWÀìÙø       ó               S i d e b a r . c s . m e t a <‡    x b     ½“    çC‘çìÙĞ±âù¯ÙM
çìÙ†Ë$èìÙp       j                S i d e b a r A n c h o r . c s . m e Ã“    € l     ½“    eÚuWÀìÙ P›î‚¤Ù(B‡ÀäÙrvWÀìÙø       ó                S i d e b a r A n c h o r . c s . m e t a     Ä“    p `     ½“    ZOvWÀìÙ P›î‚¤Ù'‡ÀäÙRvvWÀìÙ        B               S i d e b a r P a n e l . c s Å“    € j     ½“    º®vWÀìÙ P›î‚¤Ù8o‡ÀäÙ¯ÕvWÀìÙø       ó                S i d e b a r P a n e l . c  . m e t a       B‡    € l     ½“    #Í‘çìÙp8äù¯ÙM
çìÙD™Ë$èìÙ       ú               S i d e b a r P a n e l W i n d o w . c s . m Ç“    ˆ v     ½“    ÄnwWÀìÙ P›î‚¤Ùh‡ÀäÙË•wWÀìÙø       ó                S i d e b a r P a n e l W i n d o w . c s . m e t a   @‡    h X     ½“    ¢~‘çìÙp8äù¯ÙM
çìÙ3rË$èìÙ       }               S i d e b a r s . c s É“    x b     ½“    š&xWÀìÙ P›î‚¤ÙĞ	‡ÀäÙ MxWÀìÙø       ó                S i d e b a r s . c s . m e t a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       using UnityEditor;
using UnityEngine;

namespace Unity.VisualScripting
{
    public sealed class SidebarPanel
    {
        public SidebarPanel(ISidebarPanelContent content)
        {
            Ensure.That(nameof(content)).IsNotNull(content);

            this.content = content;
        }

        [DoNotSerialize]
        public Sidebars sidebars { get; set; }

        [DoNotSerialize]
        public Sidebar sidebar => sidebars[anchor];

        [DoNotSerialize]
        public bool enabled { get; private set; }

        [Serialize]
        private object controlHint;

        [Serialize]
        public float height { get; set; }

        [Serialize]
        public SidebarAnchor anchor { get; set; }

        [Serialize]
        private Vector2 scroll;

        [Serialize]
        public int order { get; set; }

        [DoNotSerialize]
        private EventWrapper e;

        [DoNotSerialize]
        private ISidebarPanelContent _content;

        [DoNotSerialize]
        public ISidebarPanelContent content
        {
            get => _content;
            private set
            {
                _content = value;
                controlHint = content?.sidebarControlHint;
                e = new EventWrapper(controlHint);
                enabled = content != null;
            }
        }

        [DoNotSerialize]
        private bool isResizing;

        public bool TryAssociate(ISidebarPanelContent content)
        {
            if (content.sidebarControlHint == controlHint)
            {
                this.content = content;
                return true;
            }
            else
            {
                return false;
            }
        }

        public void Disable()
        {
            _content = null;
            enabled = false;
        }

        public void OnGUI(Rect position, ref float y, float? heightOverride = null)
        {
            if (content == null)
            {
                var message = "Missing sidebar content.";
                var messageType = MessageType.Warning;
                var messageHeight = LudiqGUIUtility.GetHelpBoxHeight(message, messageType, position.width);
                EditorGUI.HelpBox(position.VerticalSection(ref y, messageHeight), message, messageType);
                return;
            }

            var height = heightOverride ?? this.height;

            var panelPosition = new Rect
                (
                position.x,
                y,
                position.width,
                height
                );

            var titlePosition = new Rect
                (
                position.x,
                y,
                position.width,
                Styles.title.fixedHeight
                );

            if (e.IsRepaint)
            {
                Styles.title.Draw(titlePosition, content.titleContent, false, false, false, false);
            }

            var orderSpinnerPosition = new Rect
                (
                position.xMax - Styles.orderSpinnerWidth,
                y,
                Styles.orderSpinnerWidth,
                titlePosition.height
                );

            sidebar.OrderSpinner(orderSpinnerPosition, this);

            var anchorButtonPosition = new Rect
                (
                orderSpinnerPosition.x - Styles.anchorButtonWidth,
                y,
                Styles.anchorButtonWidth,
                titlePosition.height
                );

            DrawAnchorButton(anchorButtonPosition);

            y += titlePosition.height;

            var panelContentPosition = new Rect
                (
                position.x,
                y,
                position.width,
                height - titlePosition.height
                );

            if (e.IsRepaint)
            {
                Styles.background.Draw(panelContentPosition, false, false, false, false);
            }

            LudiqGUIUtility.BeginScrollablePanel(panelContentPosition, content.GetHeight, out var panelInnerPosition, ref scroll, new RectOffset(1, 1, 0, 0));

            content.OnGUI(panelInnerPosition);

            LudiqGUIUtility.EndScrollablePanel();

            y += panelContentPosition.height;

            if (heightOverride == null)
            {
                HandleResize(panelPosition);
            }
        }

        private void DrawAnchorButton(Rect position)
        {
            SidebarAnchor destination;
            EditorTexture icon;

            switch (anchor)
            {
                case SidebarAnchor.Left:
                    destination = SidebarAnchor.Right;
                    icon = BoltCore.Icons.sidebarAnchorRight;
                    break;

                case SidebarAnchor.Right:
                    destination = SidebarAnchor.Left;
                    icon = BoltCore.Icons.sidebarAnchorLeft;
                    break;

                default:
                    throw new UnexpectedEnumValueException<SidebarAnchor>(anchor);
            }

            if (GUI.Button(position, icon?.Single(), LudiqStyles.toolbarButton))
            {
                anchor = destination;
            }
        }

        private void HandleResize(Rect panelPosition)
        {
            var resizeArea = new Rect
                (
                panelPosition.x,
                panelPosition.yMax - (Styles.resizeGrip / 2),
                panelPosition.width - Styles.orderSpinnerWidth,
                Styles.resizeGrip
                );

            EditorGUIUtility.AddCursorRect(resizeArea, MouseCursor.ResizeVertical);

            e.HandleCapture(resizeArea.Contains(e.mousePosition), false);

            if (e.IsMouseDown(MouseButton.Left) && resizeArea.Contains(e.mousePosition))
            {
                isResizing = true;
            }

            if (isResizing && e.IsMouseUp(MouseButton.Left))
            {
                isResizing = false;
            }

            if (isResizing && e.IsMouseDrag(MouseButton.Left))
            {
                height = e.mousePosition.y - panelPosition.y;
            }

            e.HandleRelease();
        }

        private static class Styles
        {
            public static readonly GUIStyle background;
            public static readonly GUIStyle title;
            public static readonly float resizeGrip = 14f;
            public static readonly float orderSpinnerWidth = LudiqGUIUtility.scrollBarWidth;
            public static readonly float anchorButtonWidth = 22;

            static Styles()
            {
                background = ColorPalette.unityBackgroundLight.CreateBackground();

                title = new GUIStyle(EditorStyles.toolbar);
                title.fontSize = 11;
                title.alignment = TextAnchor.MiddleLeft;
                title.padding = new RectOffset(4, 4, 0, 0);
                title.imagePosition = ImagePosition.ImageLeft;
                title.fixedHeight = 18;
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Òô†`>¬sÒÈ•Ú9ˆmÒô†`>¬sÒÈ•Ú˜#æÃD‹ï`>¬sÒ²òC\º	zD‹ï`>¬sÒ²òC\ÖçşÓCe>¬sÒzqğôdÇCe>¬sÒzqğc‹%Ce>¬sÒñªfæ1ÍCe>¬sÒñª@wBòº€>¬sÒÈ•Úp­º€>¬sÒÈ•ÚêĞ¤=ƒ!Ï>¬sÒñªUİæ8ƒ!Ï>¬sÒñªŞ¯åVƒ!Ï>¬sÒzqğ‡k¾ƒ!Ï>¬sÒzqğãçÈWá>¬sÒ©Û€±ëığÈWá>¬sÒôp‹Í±ëığ ¯Î¶RÓéŸîPK¤°üğÕ[«¦§nX®ö/à¢"İwÙ›¼&íï2T|TwDİwÙn‡‚IÇTwDİwÙå|a³Ò«\kTwDİwÙ°ŠµÒ«\kÎx İwÙœº¹®Ç“—uÎx İwÙWZ–eJF›]µiºİwÙ›¼&íù0|Ì]µiºİwÙ›¼&íülíşë¶O½ÊœÙ›¼&íRËÍyë¶O½ÊœÙ›¼&í;×NöS œÓÊœÙ¨×PÉaHÀäAúÊœÙÇ¦›TÃ8ğ4
LàæÙv´Dåe*óz€‚6LàæÙ†D úPNDåÇ{¹8LàæÙìf¬5¶ wİ =LàæÙ[_ô>7»Dù¸¾>LàæÙLÙ´¯ücÑJïµåsLàæÙ;ò—2„#ltøµˆLàæÙxû Å.‹GÕl”LàæÙfªVê8Ôÿßˆ‹Ÿ8Û<êö<0Í[ßˆ‹Ÿ8Û<êö<Lë‹…‚G±·îFÛi4ÆK`ÔJkøºªKŠ%qÜU]Œ±’Ag	Õ¿«Ã]Ş5h?¬Ñ…ü&;fkñg8ß‹{èRğS&;fkñg8ßóäÕt¬2[‘É‚=áqõı6Ğ˜éo2[‘É‚=áqõı6D‡s¢Õº#[„ÇáÒ\
¦®‰oÕº#[„ÇáÒ\
¦Çâÿÿæä?9ã3ú].¼Hÿæä?9ã|pO²ŸbªŠ²tŠ†Øæ›¼&íÆpI€ ›şü†Øæ›¼&í9”À ›şü†Øæ›¼&íöP²È9±u{;¸çI€:¹ÒˆA9±u{;¸çI€:¹!=pÕ[ZØ}d3aé)awƒà‚Šmnâoé›¼&í¸æô?Šmnâoé›¼&í«¡Çõ°¥®	nâoéÖ¨Ø@5y°¥®	nâoé­©Í5y#Ğq2¤ šéÈ•Ú±¤³Ú#Ğq2¤ šéÈ•Úfb‰Şi?¡°äñëG¡³²l3ŸúI'jÿÂì'‰åcvİÍ@—jÿÂì›¼&í±PİÍ@—jÿÂì›¼&í4d_öÌ‘³jÿÂì›¼&ííkT9ôÒ®/š³íK»Nø2$K—6íùóÒ“Cî=€àşßŠİj— Tî› µği5š³=ÅEªî1cWh‡M š³=ÅEªî¨×PÒ¯Ô1š³=ÅEªî›¼&íVKSš³=ÅEªîœº¹®Œt‚š³=ÅEªîWZ–eH¾°úÕº#[à²Lï†$Ÿ®‰oÕº#[à²Lï†$ŸÇâÿ&;fkà²Lïø½Š­RğS&;fkà²LïÜİ±äÕt¬¹"pà²Lïs`cŞä„¹"pà²Lï“ËsŞä„¹"pà²Lïvù2ˆD(¶¹"pà²LïÓÚ¬WˆD(¶¨.'é\±Ìïaèô7Ë"|¨.'é\±ÌïL´j7£ê³ÖG™ƒáòÒøBÑ²lõ™·«ƒáò¸À0Æ»¤Õ´×ãÀƒáòÍŞW¨nE	cYaW/ùƒÒô&>çC÷,U&ÂQù;t§…¬ig÷,U&ÂQùX†!›¬iguTxBÙ‡úŞu=MÕê    #m NXÂ4yåªÑ’M                cšÙ€İTÌQõbæt·5   ˜—      ˜—                  „—      |—      t—     l—      æ;¦aøı#*¼_ìÕ                cšÙ€İTÌQõbæt·5   4—      4—                   —      —      —     —      @*&x°vûx(—cSİX                cšÙ€İTÌQõbæt·5   Ğ–      Ğ–                  ¼–      ´–      ¬–     ¤–      DÿM4y©<RíØ·]’Kp                cšÙ€İTÌQõbæt·5   l–      l–                  X–      P–      H–     @–      g’‚4y©<RíØ·d'A›                cšÙ€İTÌQõbæt·5   –      –                  ô•      ì•      ä•     Ü•      l’çı“Üém£9-                cšÙ€İTÌQõbæt·5   ¤•      ¤•                  •      ˆ•      €•     x•      ¨0ŞÆ„Jk‹ÜZ {Íñk                cšÙ€İTÌQõbæt·5   @•      @•                  ,•      $•      •     •      ¤}æJéCv†?…Á                cšÙ€İTÌQõbæt·5   Ü”      Ü”                  È”      À”      ¸”     °”      NŒÃërê=9eSÃ~iè                cšÙ€İTÌQõbæt·5   x”      x”                  d”      \”      T”     L”      ˆÜuA¿ª0îĞ6HÇ5»                cšÙ€İTÌQõbæt·5   ”      ”                   ”      ø“      ğ“     è“      pöQ8§?QK
]v7gæ                cšÙ€İTÌQõbæt·5   °“      °“                  œ“      ”“      Œ“     „“      Ü÷Œ…Yîì»ûdÉS¦ÊÖW                cšÙ€İTÌQõbæt·5   L“      L“                  8“      0“      (“      “      olRw®½Áı¯ºPWc4                cšÙ€İTÌQõbæt·5   è’      è’                  Ô’      Ì’      Ä’     ¼’      ¦ÂåÜ®½Áı¯ºPšã¹e                cšÙ€İTÌQõbæt·5   „’      „’                  p’      h’      `’     X’      fT/öYì!2~ş³ÒjL†”                cšÙ€İTÌQõbæt·5    ’       ’                  ’      ’      ü‘     ô‘      fT/öYì!2~ş³ÒjL†”                cšÙ€İTÌQõbæt·5   ¼‘      ¼‘                  ¨‘       ‘      ˜‘     ‘      ñÚÄ·ƒ6¯ó‘°ÜU€ÿ                cšÙ€İTÌQõbæt·5   X‘      h‘                  T‘      L‘      D‘     <‘      r´³WËŒ½Œ4ï L]*ª`                cšÙ€İTÌQõbæt·5   ‘      ‘                  ğ      è      à     Ø      ½‰/û‘"ş~¢!?]ZÑ‰                cšÙ€İTÌQõbæt·5          °                  œ      ”      Œ     „      	<„<ÚTğAnc*Yª¼                cšÙ€İTÌQõbæt·5   L      L                  8      0      (            Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   è      è                  Ô      Ì      Ä     ¼      ˆÅäË8dî¿b>3 õ                cšÙ€İTÌQõbæt·5   „      „                  p      h      `     X      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5                                         ü     ô      ï€E—$Vy·â”“`                cšÙ€İTÌQõbæt·5   ¼      ¼                  ¨             ˜           3;I.® Q¶(­8ÌŸ                cšÙ€İTÌQõbæt·5   X      X                  D      <      4     ,      pøl¬Û´4ï LœÇæ                cšÙ€İTÌQõbæt·5   ô      ô                  à      Ø      Ğ     È      v“Š¯}pbig)jĞV¾|7                cšÙ€İTÌQõbæt·5                           |      t      l     d      MÕÉ|ç`…Í¶én°Hh                cšÙ€İTÌQõbæt·5   ,      ,                                          ´ÿ Aåá)›îªª´r\                cšÙ€İTÌQõbæt·5   ÈŒ      ÈŒ                  ´Œ      ¬Œ      ¤Œ     œŒ      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   dŒ      dŒ                  PŒ      HŒ      @Œ     8Œ      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5    Œ       Œ                  ì‹      ä‹      Ü‹     Ô‹      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   œ‹      œ‹                  ˆ‹      €‹      x‹     p‹      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   8‹      8‹                  $‹      ‹      ‹     ‹      «;Sï’ĞÊ—iGÃ                cšÙ€İTÌQõbæt·5   ÔŠ      ÔŠ                  ÀŠ      ¸Š      °Š     ¨Š      Ë5Oèõº1æQìB‹ğuA                cšÙ€İTÌQõbæt·5   pŠ      pŠ                  \Š      TŠ      LŠ     DŠ      jà’6¤µoåâ—®ëHe                cšÙ€İTÌQõbæt·5   Š      Š                  ø‰      ğ‰      è‰     à‰      ®çMùv¸‰‘¢V¢1—X¹                cšÙ€İTÌQõbæt·5   ¨‰      ¨‰                  ”‰      Œ‰      „‰     |‰      ¸ÅW¦»½âmÜel                cšÙ€İTÌQõbæt·5   D‰      D‰                  0‰      (‰       ‰     ‰      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   àˆ      àˆ                  Ìˆ      Äˆ      ¼ˆ     ´ˆ      ¼áª™£\Ÿ›J«sV                cšÙ€İTÌQõbæt·5   |ˆ      |ˆ                  hˆ      `ˆ      Xˆ     Pˆ      Z”$•»½Rqò
 k                cšÙ€İTÌQõbæt·5   ˆ      ˆ                  ˆ      ü‡      ô‡     ì‡      îœ+"±—uõbæt­‘qã                cšÙ€İTÌQõbæt·5   ´‡      ´‡                   ‡      ˜‡      ‡     ˆ‡      Ü.X$¦\l¬ª2Î¦                cšÙ€İTÌQõbæt·5   P‡      P‡                  <‡      4‡      ,‡     $‡      TdvèN´•½—ZB–+                cšÙ€İTÌQõbæt·5   ì†      ì†                  Ø†      Ğ†      È†     À†      U¦ÏO>¥âØøI®è‡]½                cšÙ€İTÌQõbæt·5   ˆ†      ˆ†                  t†      l†      d†     \†      ÁÅ½Föƒí‰Bc0J0                cšÙ€İTÌQõbæt·5   $†      $†                  †      †       †     ø…      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   À…      À…                  ¬…      ¤…      œ…     ”…      İ[aø–õ•l=ù·ov‰í                cšÙ€İTÌQõbæt·5   \…      \…                  H…      @…      8…     0…      x£Ñ€yş?.PZi-õ‡è                cšÙ€İTÌQõbæt·5   ø„      ø„                  ä„      Ü„      Ô„     Ì„      û¢±-(QsÿŠŸ2ÈOÏ]                cšÙ€İTÌQõbæt·5   ”„      ”„                  €„      x„      p„     h„      ›®¾:·uŒC&W¬Ô÷                cšÙ€İTÌQõbæt·5   0„      0„                  „      „      „     „      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   Ìƒ      Ìƒ                  ¸ƒ      °ƒ      ¨ƒ      ƒ      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   hƒ      hƒ                  Tƒ      Lƒ      Dƒ     <ƒ      Wş»m.ÈÜØƒ~TÅ˜ä                cšÙ€İTÌQõbæt·5   ƒ      ƒ                  ğ‚      è‚      à‚     Ø‚      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5    ‚       ‚                  Œ‚      „‚      |‚     t‚      ám¸·İ®„E}ÄšÅ1ƒ                cšÙ€İTÌQõbæt·5   <‚      <‚                  (‚       ‚      ‚     ‚      Ü/µ²|—·„LÙL_³¦*                cšÙ€İTÌQõbæt·5   Ø      Ø                  Ä      ¼      ´     ¬      Ú™ª>©çNªÚ¦IM³A$‚                cšÙ€İTÌQõbæt·5   t      t                  `      X      P     H      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5                           ü€      ô€      ì€     ä€      Ò‰î:}ız2Ác‰Î4                cšÙ€İTÌQõbæt·5   ¬€      ¬€                  ˜€      €      ˆ€     €€      {½>.÷¬;Ü¨ÉeVXÚ                cšÙ€İTÌQõbæt·5   H€      H€                  4€      ,€      $€     €      "ô%rÌzJ)'yÆÆqõù                cšÙ€İTÌQõbæt·5   ä      ä                  Ğ      È      À     ¸      ­•Y(ç¾v$Í{!€Ìg                cšÙ€İTÌQõbæt·5   €      €                  l      d      \     T      fT/öYì!2~ş³ÒjL†”                cšÙ€İTÌQõbæt·5                                        ø~     ğ~      Å"öƒÍê…5'åS^                cšÙ€İTÌQõbæt·5   ¸~      ¸~                  ¤~      œ~      ”~     Œ~      …>"4=uf›4Î?´A´                cšÙ€İTÌQõbæt·5   T~      d~                  P~      H~      @~     8~      
yõ	8èáƒç¹5Iü                cšÙ€İTÌQõbæt·5    ~       ~                  ì}      ä}      Ü}     Ô}      –œ0‰Å¸ùı„#,Óô                cšÙ€İTÌQõbæt·5   œ}      œ}                  ˆ}      €}      x}     p}      ÿ­ÀI½ø€Fõş*dÌ                cšÙ€İTÌQõbæt·5   8}      H}                  4}      ,}      $}     }      ?mù²«Ô/"Y Íxú                cšÙ€İTÌQõbæt·5   ä|      ô|                  à|      Ø|      Ğ|     È|      Ÿ2ºLÎéchÙ,¶Ê“³                cšÙ€İTÌQõbæt·5   |      |                  ||      t|      l|     d|      ªx[9}`Zµ¸mÇ¨û                cšÙ€İTÌQõbæt·5   ,|      ,|                  |      |      |      |      ¨•(Šå;kÇºP”+“                cšÙ€İTÌQõbæt·5   È{      È{                  ´{      ¬{      ¤{     œ{      ZçüÀB©ú|<÷¡£Â                cšÙ€İTÌQõbæt·5   d{      t{                  `{      X{      P{     H{      …|¸¸:5¼BŸÀÌ…Q                cšÙ€İTÌQõbæt·5   {      {                  üz      ôz      ìz     äz      !]‘Ñß ûŞ6yİ{gõîœ                cšÙ€İTÌQõbæt·5   ¬z      ¬z                  ˜z      z      ˆz     €z      Åó±³u5€BŸÀ€> Z                cšÙ€İTÌQõbæt·5   Hz      Hz                  4z      ,z      $z     z      ™qöé³"Š§{’tMµÃn                cšÙ€İTÌQõbæt·5   äy      äy                  Ğy      Èy      Ày     ¸y      mé'‹¶jM¶álê“±l                cšÙ€İTÌQõbæt·5   €y      €y                  ly      dy      \y     Ty      –QÁß–şÙ8 /Ç+S                cšÙ€İTÌQõbæt·5   y      y                  y       y      øx     ğx      İÈßÜf¯, XŸ»v                cšÙ€İTÌQõbæt·5   ¸x      ¸x                  ¤x      œx      ”x     Œx      Æ•±XOÄ½ÒÌG²2"„                cšÙ€İTÌQõbæt·5   Tx      Tx                  @x      8x      0x     (x      }ÒÑºè4^ŞæÌ`”Ü«                 cšÙ€İTÌQõbæt·5   ğw      ğw                  Üw      Ôw      Ìw     Äw      òˆ.? ÁÜQ^l5wTÚ                cšÙ€İTÌQõbæt·5   Œw      Œw                  xw      pw      hw     `w      ¼3Û#ûeŸqpŠŸÏ&m                cšÙ€İTÌQõbæt·5   (w      (w                  w      w      w     üv      fT/öYì!2~ş³ÒjL†”                cšÙ€İTÌQõbæt·5   Äv      Äv                  °v      ¨v       v     ˜v      fT/öYì!2~ş³ÒjL†”                cšÙ€İTÌQõbæt·5   `v      `v                  Lv      Dv      <v     4v      +¢3©Yâ!ÇÉÜ‰~N                cšÙ€İTÌQõbæt·5   üu      üu                  èu      àu      Øu     Ğu      fT/öYì!2~ş³ÒjL†”                cšÙ€İTÌQõbæt·5   ˜u      ˜u                  „u      |u      tu     lu      3^fÃùQLNšâ8Âø                cšÙ€İTÌQõbæt·5   4u      4u                   u      u      u     u      &`İÌ1ş¤[½Ä×¢ÙV3                cšÙ€İTÌQõbæt·5   Ğt      Ğt                  ¼t      ´t      ¬t     ¤t      …?C !³cu§FÇÅéŞ                cšÙ€İTÌQõbæt·5   lt      lt                  Xt      Pt      Ht     @t      òuì%¬¼÷·³¹Ìúè                cšÙ€İTÌQõbæt·5   t      t                  ôs      ìs      äs     Üs      ıŠl¾;…x´u¤\                 cšÙ€İTÌQõbæt·5   ¤s      ¤s                  s      ˆs      €s     xs      U%SÎ#&éÚ†h}MY                cšÙ€İTÌQõbæt·5   @s      @s                  ,s      $s      s     s      üaÎ#&éÚ†÷}÷                cšÙ€İTÌQõbæt·5   Ür      Ür                  Èr      Àr      ¸r     °r      Kæİ()˜Pôdî¿búR                cšÙ€İTÌQõbætï»¿The MIT License (MIT)

Copyright (c) Microsoft Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     INDX( 	 Wÿ)           (   	  è      
 i  n i o t           ğ“    x b     Í“    !‡WÀìÙN`[çìÙN`[çìÙ…Ô$èìÙ                        A c k n o w l e d g e m e n t s . m e Î“    € l     Í“    ıyWÀìÙ P›î‚¤Ù{é†ÀäÙB$zWÀìÙ°       ¬                A c k n o w l e d g e m e n t s . m e t a     ó“    h T     Í“    Ï%ˆWÀìÙ@\çìÙ@\çìÙ…Ô$èìÙ                       	 A n a l y t i c s . m Ï“    p ^     Í“    ¾ZzWÀìÙ P›î‚¤Ù(Äå†ÀäÙ€‚zWÀìÙ°       ¬                A n a l y t 
 c s . m e t a   Ô}    € n     Í“    SD?çìÙ ˜åù¯Ù‘‹^çìÙD™Ë$èìÙ       Õ               B o l t F l o w N a m e U t i l i t y . c s . Ñ“    ˆ x     Í“    ñ{WÀìÙ P›î‚¤Ù 6ã†ÀäÙô;{WÀìÙø       ó                B o l t F l o w N a m e U t i l i t y . c s . m e t a ö“    h X     Í“    -_‰WÀìÙeı\çìÙeı\çìÙ5é]éìÙ                        C o n n e c t i o n s Ò“    x b     Í“    ß‰{WÀìÙ P›î‚¤ÙÀ?Ò†ÀäÙ7¤{WÀìÙ°       ¬                C o n n e c t i o n s . m e t a       ”   
 h X     Í“    —(WÀìÙÀ²^çìÙÀ²^çìÙ5é]éìÙ                        D e s c r i p t i o n Ó“    x b     Í“    Û{WÀìÙ P›î‚¤Ùãë¸†ÀäÙx|WÀìÙ°       ¬                D e s c r i p t i o n . m e t a       ”    ` N     Í“    ¹x—WÀìÙÓv_çìÙÓv_çìÙ½]éìÙ                        E v e n t s . Ô“    h X     Í“    rU|WÀìÙ P›î‚¤Ù]Ş©†ÀäÙTs|WÀìÙ°       ¬                E v e n t s . m e t a Õ“    p \     Í“    WÁ|WÀìÙ P›î‚¤Ù—ä¨†ÀäÙWÁ|WÀìÙ P      öA               F l o w C a 
 v a s . c s     Ö“    x f     Í“    <}WÀìÙ P›î‚¤Ù’ô¦†ÀäÙ”6}WÀìÙø       ó                F l o w C a n v a s . c s . m e t a   Õ}    ˆ t     Í“    sk?çìÙ÷æù¯Ù‘‹^çìÙç¬Ë$èìÙ`      \               F l o w D r a g A n d D r o p U t i l i t y . c s . m Ø“     ~     Í“    ÷æ}WÀìÙ P›î‚¤Ùb¤†ÀäÙ÷æ}WÀìÙX       V                F l o w D r a g A n d D r o p U t i l i t y . c s . m e t a   Ø}    € l     Í“    ›Í?çìÙ÷æù¯ÙËĞ`çìÙç¬Ë$èìÙ€      ~               F l o w E d 
 t o r B i n d i n g s . c s . m Ú“    ˆ v     Í“    Í¾~WÀìÙ P›î‚¤Ù(º¡†ÀäÙÍ¾~WÀìÙø       ó                F l o w E d i t o r B i n d i n g s . c s . m e t a   ×}    x h     Í“    ›Í?çìÙ÷æù¯Ù¡©`çìÙ3rË$èìÙ                      F l o w G r a p h C o n t e x t . c s                     maWÀìÙ P›î‚¤ÙãœŸ†ÀäÙrˆWÀìÙø       ó                F l o w G r a p h C o n t e x t . c s . m e t a                     Í“    QMWÀìÙ P›î‚¤Ù¢~+ìÙ-^WÀìÙĞ       Ğ                F l 
 w M a c h i n e E d i t o r . c s       â“    ˆ t     Í“    C”WÀìÙ P›î‚¤ÙOõ˜†ÀäÙH»WÀìÙø       ó                F l o w M a c h i n e E d i t o r . c s . m e t a     ã“    p ^     Í“    è‚WÀìÙ P›î‚¤Ù\5ñ…ÀäÙè‚WÀìÙ°       ¬                F r a m e w o r k . m e t a   ä“    x b     Í“    Ó_‚WÀìÙ P›î‚¤ÙƒÙê…ÀäÙÓ_‚WÀìÙ°       ¬                I n v o c a t i o n s . m e t a       å“    p Z     Í“    m¶‚WÀìÙ P›î‚¤Ù@ªÑ…ÀäÙâ‚WÀìÙ°       ¬                O p t i o n s . m e 
 a       æ“    h X     Í“    a1ƒWÀìÙ P›î‚¤ÙÄÔs…ÀäÙa1ƒWÀìÙ°       ¬                P l u g i n . m e t a ç“    h V     Í“    &¦ƒWÀìÙ P›î‚¤Ù…'T…ÀäÙ&¦ƒWÀìÙ°       ¬               
 P o r t s . m e t a   è“    p `     Í“    âòƒWÀìÙ P›î‚¤ÙâP…ÀäÙò„WÀìÙ°       ¬                P r o p e r t i e s . m e t a é“    x h     Í“    á\„WÀìÙ P›î‚¤Ù>Á~+ìÙtr„WÀìÙ       Ó               R u n t i m e G r a p h B a s e . c s ê“    ˆ r     Í“    ¦¡„WÀìÙ P›î‚¤Ù]®L…ÀäÙıË„WÀìÙX     
 V                R u n t i m e G r a p h B a s e . c s . m e t a       ë“    h V     Í“    €-…WÀìÙ P›î‚¤ÙR×>…ÀäÙ€-…WÀìÙ°       ¬               
 U n i t s . m e t a   ì“    ¨ ’     Í“    ‡o…WÀìÙ P›î‚¤Ù>İ=…ÀäÙ–…WÀìÙ       Ò              ( U n i t y . V i s u a l S c r i p t i n g . F l o w . E d i t o r . a s m d e f                                                                                                                                                                           
 using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityObject = UnityEngine.Object;

namespace Unity.VisualScripting
{
    [Canvas(typeof(FlowGraph))]
    public sealed class FlowCanvas : VisualScriptingCanvas<FlowGraph>
    {
        public FlowCanvas(FlowGraph graph) : base(graph) { }


        #region Clipboard

        public override void ShrinkCopyGroup(HashSet<IGraphElement> copyGroup)
        {
            copyGroup.RemoveWhere(element =>
            {
                if (element is IUnitConnection)
                {
                    var connection = (IUnitConnection)element;

                    if (!copyGroup.Contains(connection.source.unit) ||
                        !copyGroup.Contains(connection.destination.unit))
                    {
                        return true;
                    }
                }

                return false;
            });
        }

        #endregion


        #region Window

        public override void OnToolbarGUI()
        {
            showRelations = GUILayout.Toggle(showRelations, "Relations", LudiqStyles.toolbarButton);

            EditorGUI.BeginChangeCheck();

            BoltFlow.Configuration.showConnectionValues = GUILayout.Toggle(BoltFlow.Configuration.showConnectionValues, "Values", LudiqStyles.toolbarButton);

            BoltCore.Configuration.dimInactiveNodes = GUILayout.Toggle(BoltCore.Configuration.dimInactiveNodes, "Dim", LudiqStyles.toolbarButton);

            if (EditorGUI.EndChangeCheck())
            {
                BoltFlow.Configuration.Save();

                BoltCore.Configuration.Save();
            }

            base.OnToolbarGUI();
        }

        #endregion


        #region View

        protected override bool shouldEdgePan => base.shouldEdgePan || isCreatingConnection;

        public const float inspectorZoomThreshold = 0.7f;

        #endregion


        #region Lifecycle

        public override void Close()
        {
            base.Close();

            CancelConnection();
        }

        protected override void HandleHighPriorityInput()
        {
            if (isCreatingConnection)
            {
                if (e.IsMouseDown(MouseButton.Left))
                {
                    connectionEnd = mousePosition;
                    NewUnitContextual();
                    e.Use();
                }
                else if (e.IsFree(EventType.KeyDown) && e.keyCode == KeyCode.Escape)
                {
                    CancelConnection();
                    e.Use();
                }
            }

            base.HandleHighPriorityInput();
        }

        private void CompleteContextualConnection(IUnitPort source, IUnitPort destination)
        {
            source.ValidlyConnectTo(destination);
            Cache();
            var unitPosition = this.Widget<IUnitWidget>(destination.unit).position.position;
            var portPosition = this.Widget<IUnitPortWidget>(destination).handlePosition.center.PixelPerfect();
            var offset = portPosition - unitPosition;
            destination.unit.position -= offset;
            this.Widget(destination.unit).Reposition();
            connectionSource = null;
            GUI.changed = true;
        }

        public void NewUnitContextual()
        {
            var filter = UnitOptionFilter.Any;
            filter.GraphHashCode = graph.GetHashCode();

            if (connectionSource is ValueInput)
            {
                var valueInput = (ValueInput)connectionSource;
                filter.CompatibleOutputType = valueInput.type;
                filter.Expose = false;
                filter.NoConnection = false;
                NewUnit(mousePosition, GetNewUnitOptions(filter), (unit) => CompleteContextualConnection(valueInput, unit.CompatibleValueOutput(valueInput.type)));
            }
            else if (connectionSource is ValueOutput)
            {
                var valueOutput = (ValueOutput)connectionSource;
                filter.CompatibleInputType = valueOutput.type;
                filter.NoConnection = false;
                NewUnit(mousePosition, GetNewUnitOptions(filter), (unit) => CompleteContextualConnection(valueOutput, unit.CompatibleValueInput(valueOutput.type)));
            }
            else if (connectionSource is ControlInput)
            {
                var controlInput = (ControlInput)connectionSource;
                filter.NoControlOutput = false;
                filter.NoConnection = false;
                NewUnit(mousePosition, GetNewUnitOptions(filter), (unit) => CompleteContextualConnection(controlInput, unit.controlOutputs.First()));
            }
            else if (connectionSource is ControlOutput)
            {
                var controlOutput = (ControlOutput)connectionSource;
                filter.NoControlInput = false;
                filter.NoConnection = false;
                NewUnit(mousePosition, GetNewUnitOptions(filter), (unit) => CompleteContextualConnection(controlOutput, unit.controlInputs.First()));
            }
        }

        #endregion


        #region Context

        protected override void OnContext()
        {
            if (isCreatingConnection)
            {
                CancelConnection();
            }
            else
            {
                // Checking for Alt seems to lose focus, for some reason maybe
                // unrelated to Bolt. Shift or other modifiers seem to work though.
                if (base.GetContextOptions().Any() && (!BoltFlow.Configuration.skipContextMenu || e.shift))
                {
                    base.OnContext();
                }
                else
                {
                    NewUnit(mousePosition);
                }
            }
        }

        protected override IEnumerable<DropdownOption> GetContextOptions()
        {
            yield return new DropdownOption((Action<Vector2>)(NewUnit), "Add Node...");
            yield return new DropdownOption((Action<Vector2>)(NewSticky), "Create Sticky Note");
            foreach (var baseOption in base.GetContextOptions())
            {
                yield return baseOption;
            }
        }

        public void AddUnit(IUnit unit, Vector2 position)
        {
            UndoUtility.RecordEditedObject("Create Node");
            unit.guid = Guid.NewGuid();
            unit.position = position.PixelPerfect();
            graph.units.Add(unit);
            selection.Select(unit);
            GUI.changed = true;
        }

        private UnitOptionTree GetNewUnitOptions(UnitOptionFilter filter)
        {
            var options = new UnitOptionTree(new GUIContent("Node"));

            options.filter = filter;
            options.reference = reference;

            if (filter.CompatibleOutputType == typeof(object))
            {
                options.surfaceCommonTypeLiterals = true;
            }

            return options;
        }

        private void NewSticky(Vector2 position)
        {
            UndoUtility.RecordEditedObject("Create Sticky Note");
            var stickyNote = new StickyNote() { position = new Rect(position, new Vector2(100, 100)) };
            graph.elements.Add(stickyNote);
            selection.Select(stickyNote);
            GUI.changed = true;
        }

        private void NewUnit(Vector2 position)
        {
            var filter = UnitOptionFilter.Any;
            filter.GraphHashCode = graph.GetHashCode();
            NewUnit(position, GetNewUnitOptions(filter));
        }

        private void NewUnit(Vector2 unitPosition, UnitOptionTree options, Action<IUnit> then = null)
        {
            delayCall += () =>
            {
                var activatorPosition = new Rect(e.mousePosition, new Vector2(200, 1));

                var context = this.context;

                LudiqGUI.FuzzyDropdown
                    (
                        activatorPosition,
                        options,
                        null,
                        delegate (object _option)
                        {
                            context.BeginEdit();
                            if (_option is IUnitOption)
                            {
                                var option = (IUnitOption)_option;
                                var unit = option.InstantiateUnit();
                                AddUnit(unit, unitPosition);
                                option.PreconfigureUnit(unit);
                                then?.Invoke(unit);
                                GUI.changed = true;
                            }
                            else
                            {
                                if ((Type)_option == typeof(StickyNote))
                                {
                                    NewSticky(unitPosition);
                                }
                            }

                            context.EndEdit();
                        }
                    );
            };
        }

        #endregion


        #region Drag & Drop

        private bool CanDetermineDraggedInput(UnityObject uo)
        {
            if (uo.IsSceneBound())
            {
                if (reference.self == uo.GameObject())
                {
                    // Because we'll be able to assign it to Self
                    return true;
                }

                if (reference.serializedObject.IsSceneBound())
                {
                    // Because we'll be able to use a direct scene reference
                    return true;
                }

                return false;
            }
            else
            {
                return true;
            }
        }

        public override bool AcceptsDragAndDrop()
        {
            if (DragAndDropUtility.Is<ScriptGraphAsset>())
            {
                return FlowDragAndDropUtility.AcceptsScript(graph);
            }

            return DragAndDropUtility.Is<UnityObject>() && !DragAndDropUtility.Is<IMacro>() && CanDetermineDraggedInput(DragAndDropUtility.Get<UnityObject>())
                || EditorVariablesUtility.isDraggingVariable;
        }

        public override void PerformDragAndDrop()
        {
            if (DragAndDropUtility.Is<ScriptGraphAsset>())
            {
                var flowMacro = DragAndDropUtility.Get<ScriptGraphAsset>();
                var superUnit = new SubgraphUnit(flowMacro);
                AddUnit(superUnit, DragAndDropUtility.position);
            }
            else if (DragAndDropUtility.Is<UnityObject>())
            {
                var uo = DragAndDropUtility.Get<UnityObject>();
                var type = uo.GetType();
                var filter = UnitOptionFilter.Any;
                filter.Literals = false;
                filter.Expose = false;
                var options = GetNewUnitOptions(filter);

                var root = new List<object>();

                if (!uo.IsSceneBound() || reference.serializedObject.IsSceneBound())
                {
                    if (uo == reference.self)
                    {
                        root.Add(new UnitOption<This>(new This()));
                    }

                    root.Add(new LiteralOption(new Literal(type, uo)));
                }

                if (uo is MonoScript script)
                {
                    var scriptType = script.GetClass();

                    if (scriptType != null)
                    {
                        root.Add(scriptType);
                    }
                }
                else
                {
                    root.Add(type);
                }

                if (uo is GameObject)
                {
                    root.AddRange(uo.GetComponents<Component>().Select(c => c.GetType()));
                }

                options.rootOverride = root.ToArray();

                NewUnit(DragAndDropUtility.position, options, (unit) =>
                {
                    // Try to assign a correct input
                    var compatibleInput = unit.CompatibleValueInput(type);

                    if (compatibleInput == null)
                    {
                        return;
                    }

                    if (uo.IsSceneBound())
                    {
                        if (reference.self == uo.GameObject())
                        {
                            // The component is owned by the same game object as the graph.

                            if (compatibleInput.nullMeansSelf)
                            {
                                compatibleInput.SetDefaultValue(null);
                            }
                            else
                            {
                                var self = new This();
                                self.position = unit.position + new Vector2(-150, 19);
                                graph.units.Add(self);
                                self.self.ConnectToValid(compatibleInput);
                            }
                        }
                        else if (reference.serializedObject.IsSceneBound())
                        {
                            // The component is from another object from the same scene
                            compatibleInput.SetDefaultValue(uo.ConvertTo(compatibleInput.type));
                        }
                        else
                        {
                            throw new NotSupportedException("Cannot determine compatible input from dragged Unity object.");
                        }
                    }
                    else
                    {
                        compatibleInput.SetDefaultValue(uo.ConvertTo(compatibleInput.type));
                    }
                });
            }
            else if (EditorVariablesUtility.isDraggingVariable)
            {
                var kind = EditorVariablesUtility.kind;
                var declaration = EditorVariablesUtility.declaration;

                UnifiedVariableUnit unit;

                if (e.alt)
                {
                    unit = new SetVariable();
                }
                else if (e.shift)
                {
                    unit = new IsVariableDefined();
                }
                else
                {
                    unit = new GetVariable();
                }

                unit.kind = kind;
                AddUnit(unit, DragAndDropUtility.position);
                unit.name.SetDefaultValue(declaration.name);
            }
        }

        public override void DrawDragAndDropPreview()
        {
            if (DragAndDropUtility.Is<ScriptGraphAsset>())
            {
                GraphGUI.DrawDragAndDropPreviewLabel(DragAndDropUtility.offsetedPosition, DragAndDropUtility.Get<ScriptGraphAsset>().name, typeof(ScriptGraphAsset).Icon());
            }
            else if (DragAndDropUtility.Is<GameObject>())
            {
                var gameObject = DragAndDropUtility.Get<GameObject>();
                GraphGUI.DrawDragAndDropPreviewLabel(DragAndDropUtility.offsetedPosition, gameObject.name + "...", gameObject.Icon());
            }
            else if (DragAndDropUtility.Is<UnityObject>())
            {
                var obj = DragAndDropUtility.Get<UnityObject>();
                var type = obj.GetType();
                GraphGUI.DrawDragAndDropPreviewLabel(DragAndDropUtility.offsetedPosition, type.HumanName() + "...", type.Icon());
            }
            else if (EditorVariablesUtility.isDraggingVariable)
            {
                var kind = EditorVariablesUtility.kind;
                var name = EditorVariablesUtility.declaration.name;

                string label;

                if (e.alt)
                {
                    label = $"Set {name}";
                }
                else if (e.shift)
                {
                    label = $"Check if {name} is defined";
                }
                else
                {
                    label = $"Get {name}";
                }

                GraphGUI.DrawDragAndDropPreviewLabel(DragAndDropUtility.offsetedPosition, label, BoltCore.Icons.VariableKind(kind));
            }
        }

        #endregion


        #region Drawing

        public bool showRelations { get; set; }

        #endregion


        #region Connection Creation

        public IUnitPort connectionSource { get; set; }

        public Vector2 connectionEnd { get; set; }

        public bool isCreatingConnection => connectionSource != null &&
        connectionSource.unit != null;                                     // Make sure the port didn't get destroyed: https://support.ludiq.io/communities/5/topics/4034-x

        public void CancelConnection()
        {
            connectionSource = null;
        }

        #endregion
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          using System;
using System.Text.RegularExpressions;

namespace Unity.VisualScripting.Analytics
{
    internal static class AnalyticsUtilities
    {
        internal static string AnonymizeException(Exception e)
        {
            const string pathSectionOutsidePackage = "in (?<P>.*)Packages\\\\com.unity.visualscripting";
            // Placing a '^' character to distinguish these lines from file paths outside our package
            const string pathSectionOutsidePackageReplacement = "in ^Packages\\com.unity.visualscripting";

            var anonymizedString = Regex.Replace(e.ToString(), pathSectionOutsidePackage, pathSectionOutsidePackageReplacement);

            // Detecting any callstack line that doesn't match our previously anonymized package paths
            const string filePathsOutsidePackage = ". at.*in (?<P>[^^]*:[0-9]*)";
            const string filePathsOutsidePackageReplacement = "  at <method> in <file>";

            anonymizedString = Regex.Replace(anonymizedString, filePathsOutsidePackage,
                filePathsOutsidePackageReplacement);

            return anonymizedString;
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              using UnityEditor;

namespace Unity.VisualScripting
{
    public sealed class UsageAnalytics
    {
        const int k_MaxEventsPerHour = 1000;
        const int k_MaxNumberOfElements = 1000;
        const string k_VendorKey = "unity.bolt";
        const string k_EventName = "BoltUsage";
        static bool isRegistered = false;

        public static void CollectAndSend()
        {
            if (!EditorAnalytics.enabled)
                return;

            if (!RegisterEvent())
                return;

            var data = CollectData();

            EditorAnalytics.SendEventWithLimit(k_EventName, data);
        }

        private static bool RegisterEvent()
        {
            if (!isRegistered)
            {
                var result = EditorAnalytics.RegisterEventWithLimit(k_EventName, k_MaxEventsPerHour, k_MaxNumberOfElements, k_VendorKey);
                if (result == UnityEngine.Analytics.AnalyticsResult.Ok)
                {
                    isRegistered = true;
                }
            }

            return isRegistered;
        }

        private static UsageAnalyticsData CollectData()
        {
            var data = new UsageAnalyticsData
            {
                productVersion = BoltProduct.instance.version.ToString(),
            };

            return data;
        }

        private struct UsageAnalyticsData
        {
            public string productVersion;
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Unity.VisualScripting.Analytics
{
    internal static class MigrationAnalytics
    {
        private const int MaxEventsPerHour = 120;
        private const int MaxNumberOfElements = 1000;
        private const string VendorKey = "unity.visualscripting";
        private const string EventName = "VScriptMigration";
        private static bool _isRegistered = false;

        internal static void Send(Data data)
        {
            if (!EditorAnalytics.enabled)
                return;

            if (!RegisterEvent())
                return;

            EditorAnalytics.SendEventWithLimit(EventName, data);
        }

        private static bool RegisterEvent()
        {
            if (!_isRegistered)
            {
                var result = EditorAnalytics.RegisterEventWithLimit(EventName, MaxEventsPerHour, MaxNumberOfElements, VendorKey);
                if (result == UnityEngine.Analytics.AnalyticsResult.Ok)
                {
                    _isRegistered = true;
                }
            }

            return _isRegistered;
        }

        [Serializable]
        internal class Data
        {
            [SerializeField]
            internal MigrationStepAnalyticsData total;
            [SerializeField]
            internal List<MigrationStepAnalyticsData> steps;
        }

        [Serializable]
        internal class MigrationStepAnalyticsData
        {
            [SerializeField]
            internal string pluginId;
            [SerializeField]
            internal string from;
            [SerializeField]
            internal string to;
            [SerializeField]
            internal bool success;
            [SerializeField]
            internal string exception;
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
    "name": "Unity.VisualScripting.Flow.Editor",
    "references": [
        "Unity.VisualScripting.Core",
        "Unity.VisualScripting.Core.Editor",
        "Unity.VisualScripting.Flow",
        "Unity.InputSystem"
    ],
    "optionalUnityReferences": [],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "versionDefines": [
        {
            "name": "com.unity.inputsystem",
            "expression": "1.0.1",
            "define": "PACKAGE_INPUT_SYSTEM_EXISTS"
        },
        {
            "name": "com.unity.inputsystem",
            "expression": "1.2.0",
            "define": "PACKAGE_INPUT_SYSTEM_1_2_0_OR_NEWER_EXISTS"
        }
    ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              INDX( 	 **          (   H  è      
     ÙÙi Ù          Ö}    x f     Í“    ›Í?çìÙ÷æù¯ÙEëbçìÙKË$èìÙ       İ               F l o w G r a p h E d i t o r . c s . Ş“    € p     Í“    [€WÀìÙ P›î‚¤Ùíóœ†ÀäÙ„<€WÀìÙø       ó                F l o w G r a p h E d i t o r . c s . m e t a Ù}    ˆ r     Í“    ˆõ?çìÙ÷æù¯Ù±gçìÙç¬Ë$èìÙ       4               F l o w G r a p h U n i t U I S a m p l e . c s . m e à“     |     Í“    uØ€WÀìÙ P›î‚¤ÙçÅš†ÀäÙuØ€WÀìÙø     
 ó                F l o w G r a p h U n i t U I S a m p l e . c s . m e t a     Û}    € j     Í“    „@çìÙ Wèù¯Ù™&hçìÙç¬Ë$èìÙĞ       Ğ                F l o w M a c h i n e E d i t o r . c s . m e â“    ˆ t     Í“    C”WÀìÙ P›î‚¤ÙOõ˜†ÀäÙH»WÀìÙø       ó                F l o w M a c h i n e E d i t o r . c s . m e t a     %”    h T     Í“    P‘œWÀìÙH`çìÙH`çìÙ½]éìÙ                       	 F r a m e w o r k . m ã“    p ^     Í“    è‚WÀìÙ P›î‚¤Ù\5ñ…ÀäÙè‚WÀìÙ°     
 ¬                F r a m e w o r k . m e t a   ´”    h X     Í“    ®¯ÒWÀìÙü;`çìÙü;`çìÙ?JÔ$èìÙ                        I n v o c a t i o n s ä“    x b     Í“    Ó_‚WÀìÙ P›î‚¤ÙƒÙê…ÀäÙÓ_‚WÀìÙ°       ¬                I n v o c a t i o n s . m e t a       ¹”    ` P     Í“    ŠÔWÀìÙã÷`çìÙã÷`çìÙ½]éìÙ                        O p t i o n s å“    p Z     Í“    m¶‚WÀìÙ P›î‚¤Ù@ªÑ…ÀäÙâ‚WÀìÙ°       ¬                O p t i o n s . m e t a       Ì”    ` N     Í“    ´ÛWÀì
 CçaçìÙCçaçìÙ½]éìÙ                        P l u g i n . æ“    h X     Í“    a1ƒWÀìÙ P›î‚¤ÙÄÔs…ÀäÙa1ƒWÀìÙ°       ¬                P l u g i n . m e t a •    ` L     Í“    N8üWÀìÙ¼9dçìÙ¼9dçìÙ!”]éìÙ                        P o r t s . m ç“    h V     Í“    &¦ƒWÀìÙ P›î‚¤Ù…'T…ÀäÙ&¦ƒWÀìÙ°       ¬               
 P o r t s . m e t a   :•    h V     Í“    »XÀìÙ:^açìÙ:^açìÙ?JÔ$èìÙ                       
 P r o p e r t i e s . è“    p `     Í“    âòƒWÀìÙ P›î‚¤
 âP…ÀäÙò„WÀìÙ°       ¬                P r o p e r t i e s . m e t a Ü}    x h     Í“    i«@çìÙÀİéù¯ÙŠÅiçìÙô5Ì$èìÙ       Ó               R u n t i m e G r a p h B a s e . c s ê“    ˆ r     Í“    ¦¡„WÀìÙ P›î‚¤Ù]®L…ÀäÙıË„WÀìÙX       V                R u n t i m e G r a p h B a s e . c s . m e t a       =•    ` L     Í“    õ	XÀìÙ†ÆdçìÙ†ÆdçìÙ5Óœ]éìÙ                        U n i t s . m ë“    h V     Í“    €-…WÀìÙ P›î‚¤ÙR×>…ÀäÙ€-…WÀìÙ°       ¬               
 U n 
 t s . m e t a   ì“    ¨ ’     Í“    ‡o…WÀìÙ P›î‚¤Ù>İ=…ÀäÙ–…WÀìÙ       Ò              ( U n i t y . V i s u a l S c r i p t i n g . F l o w . E d i t o r . a s m d e f       í“    ° œ     Í“    wä…WÀìÙ P›î‚¤ÙÄÛ<…ÀäÙwä…WÀìÙ¨       ¦               - U n i t y . V i s u a l S c r i p t i n g . F l o w . E d i t o r . a s m d e f . m e t a     Ş}    p \     Í“    i«@çìÙÀİéù¯ÙŠÅiçìÙô5Ì$èìÙ                      X F l o w G r a p h . c s . m ï“    x f     Í“    B—†WÀìÙ P›î‚¤
 ol:…ÀäÙu¾†WÀìÙø       ó                X F l o w G r a p h . c s . m e t a                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
 ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using UnityEditor;
using UnityEngine;

namespace Unity.PlasticSCM.Editor.UI
{
    internal static class FindEditorWindow
    {
        internal static EditorWindow ProjectWindow()
        {
            Type projectBrowserType = typeof(EditorWindow).Assembly.GetType(
                    "UnityEditor.ProjectBrowser");

            UnityEngine.Object[] windows = Resources.FindObjectsOfTypeAll(
                 projectBrowserType);

            if (windows.Length == 0)
                return null;

            return windows[0] as EditorWindow;
        }

        internal static EditorWindow ToDock<T>()
        {
            List<EditorWindow> windows = GetAvailableWindows();

            IEnumerable<EditorWindow> candidateWindows = windows
                .Where(w => !(w is T))
                .Where(w => w.position.width > 400 && w.position.height > 300)
                .OrderByDescending(w => w.position.width * w.position.height);

            return candidateWindows.FirstOrDefault();
        }

        static List<EditorWindow> GetAvailableWindows()
        {
            List<EditorWindow> result = new List<EditorWindow>();

            var hostViewField = typeof(EditorWindow).GetField(
                "m_Parent", BindingFlags.Instance | BindingFlags.NonPublic);

            if (hostViewField == null)
                return null;

            var hostViewType = hostViewField.FieldType;
            var actualViewField = hostViewType.GetField(
                "m_ActualView", BindingFlags.Instance | BindingFlags.NonPublic);

            if (actualViewField == null)
                return null;

            foreach (var window in Resources.FindObjectsOfTypeAll<EditorWindow>())
            {
                var hostView = hostViewField.GetValue(window);

                if (hostView == null)
                    continue;

                EditorWindow actualDrawnWindow = actualViewField
                    .GetValue(hostView) as EditorWindow;

                if (actualDrawnWindow == null)
                    continue;

                if (result.Contains(actualDrawnWindow))
                    continue;

                result.Add(actualDrawnWindow);
            }

            return result;
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ï»¿using System;
using System.Threading;

using Codice.LogWrapper;

namespace Unity.PlasticSCM.Editor.UI
{
    internal static class GUIActionRunner
    {
        internal delegate void ActionDelegate();

        internal static void RunGUIAction(ActionDelegate action)
        {
            if (EditorDispatcher.IsOnMainThread)
            {
                action();
                return;
            }

            lock (mLock)
            {
                ManualResetEvent syncEvent = new ManualResetEvent(false);

                EditorDispatcher.Dispatch(delegate {
                    try
                    {
                        action();
                    }
                    catch (Exception e)
                    {
                        mLog.ErrorFormat("GUI action failed: {0}", e.Message);
                        mLog.DebugFormat("Stack trace:{0}{1}", Environment.NewLine, e.StackTrace);
                        throw;
                    }
                    finally
                    {
                        syncEvent.Set();
                    }
                });

                syncEvent.WaitOne();
            }
        }

        static object mLock = new object();

        static readonly ILog mLog = LogManager.GetLogger("GUIActionRunner");
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                INDX( 	 ô¶:           (   ¸  è       Ùe l                 ”{    ˆ v     ö“    e‡[çìÙP=ëù¯Ùn]çìÙ3rË$èìÙ       b               C o n t r o l C o n n e c t i o n W i d g e t . c s . ø“     €     ö“    ¸û‰WÀìÙ P›î‚¤Ùü¨à†ÀäÙ¸û‰WÀìÙø       ó                C o n t r o l C o n n e c t i o n W i d g e t . c s . m e t a ™{    ˆ v     ö“    eı\çìÙP=ëù¯Ù+†]çìÙ†Ë$èìÙ¨      £               I n v a l i d C o n n e c t i o n W i d g e t . c s . ú“     €     ö“     ¾ŠWÀì  P›î‚¤Ù±®Ü†ÀäÙ ¾ŠWÀìÙø       ó                I n v a l i d C o n n e c t i o n W i d g e t . c s . m e t a —{    ˆ r     ö“    ‰„\çìÙP=ëù¯Ùn]çìÙD™Ë$èìÙ¨       ¢                I U n i t C o n n e c t i o n W i d g e t . c s . m e ü“     |     ö“    EŠ‹WÀìÙ P›î‚¤Ù ©Ş†ÀäÙEŠ‹WÀìÙø       ó                I U n i t C o n n e c t i o n W i d g e t . c s . m e t a     ˜{    € p     ö“    ‰„\çìÙP=ëù¯Ù+†]çìÙD™Ë$èìÙ(      $               U n i t C o n n e c t i o n S t y l  s . c s ş“     z     ö“    ¤GŒWÀìÙ P›î‚¤Ùñ•Ú†ÀäÙ&uŒWÀìÙø       ó                U n i t C o n n e c t i o n S t y l e s . c s . m e t a       ÿ“    € p     ö“    4®ŒWÀìÙ P›î‚¤ÙímÙ†ÀäÙÃÕŒWÀìÙ        l               U n i t C o n n e c t i o n W i d g e t . c s  ”     z     ö“    ÃWÀìÙ P›î‚¤Ù#™×†ÀäÙÃWÀìÙø       ó                U n i t C o n n e c t i o n W i d g e t . c s . m e t a       ”    ˆ r     ö“    „]WÀìÙ P›î‚¤Ùt¯Ö†ÀäÙˆ„WÀìÙ        v               V a  u e C o n n e c t i o n W i d g e t . c s       ”     |     ö“    {»WÀìÙ P›î‚¤ÙfÕ†ÀäÙ1ãWÀìÙø       ó                V a l u e C o n n e c t i o n W i d g e t . c s . m e t a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Unity.VisualScripting
{
    public abstract class UnitConnectionWidget<TConnection> : GraphElementWidget<FlowCanvas, TConnection>, IUnitConnectionWidget
        where TConnection : class, IUnitConnection
    {
        protected UnitConnectionWidget(FlowCanvas canvas, TConnection connection) : base(canvas, connection) { }


        #region Model

        protected TConnection connection => element;

        protected IUnitConnectionDebugData ConnectionDebugData => GetDebugData<IUnitConnectionDebugData>();

        #endregion


        #region Lifecycle

        public override void BeforeFrame()
        {
            base.BeforeFrame();

            if (showDroplets)
            {
                GraphGUI.UpdateDroplets(canvas, droplets, ConnectionDebugData.lastInvokeFrame, ref lastInvokeTime, ref dropTime);
            }
        }

        #endregion


        #region Positioning

        public override IEnumerable<IWidget> positionDependencies
        {
            get
            {
                yield return canvas.Widget(connection.source);
                yield return canvas.Widget(connection.destination);
            }
        }

        protected override bool snapToGrid => false;

        public Rect sourceHandlePosition { get; private set; }

        public Rect destinationHandlePosition { get; private set; }

        public Vector2 sourceHandleEdgeCenter { get; private set; }

        public Vector2 destinationHandleEdgeCenter { get; private set; }

        public Vector2 middlePosition;

        private Rect _position;

        private Rect _clippingPosition;

        public override Rect position
        {
            get { return _position; }
            set { }
        }

        public override Rect clippingPosition => _clippingPosition;

        public override void CachePosition()
        {
            base.CachePosition();

            sourceHandlePosition = canvas.Widget<IUnitPortWidget>(connection.source).handlePosition;
            destinationHandlePosition = canvas.Widget<IUnitPortWidget>(connection.destination).handlePosition;

            sourceHandleEdgeCenter = sourceHandlePosition.GetEdgeCenter(Edge.Right);
            destinationHandleEdgeCenter = destinationHandlePosition.GetEdgeCenter(Edge.Left);

            middlePosition = (sourceHandlePosition.center + destinationHandlePosition.center) / 2;

            _position = new Rect
                (
                middlePosition.x,
                middlePosition.y,
                0,
                0
                );

            _clippingPosition = _position.Encompass(sourceHandleEdgeCenter).Encompass(destinationHandleEdgeCenter);
        }

        #endregion


        #region Drawing

        protected virtual bool colorIfActive => true;

        public abstract Color color { get; }

        protected override bool dim
        {
            get
            {
                var dim = BoltCore.Configuration.dimInactiveNodes && !connection.destination.unit.Analysis<UnitAnalysis>(context).isEntered;

                if (BoltCore.Configuration.dimIncompatibleNodes && canvas.isCreatingConnection)
                {
                    dim = true;
                }

                return dim;
            }
        }

        public override void DrawBackground()
        {
            base.DrawBackground();

            BeginDim();

            DrawConnection();

            if (showDroplets)
            {
                DrawDroplets();
            }

            EndDim();
        }

        protected virtual void DrawConnection()
        {
            var color = this.color;

            var sourceWidget = canvas.Widget<IUnitPortWidget>(connection.source);
            var destinationWidget = canvas.Widget<IUnitPortWidget>(connection.destination);

            var highlight = !canvas.isCreatingConnection && (sourceWidget.isMouseOver || destinationWidget.isMouseOver);

            var willDisconnect = sourceWidget.willDisconnect || destinationWidget.willDisconnect;

            if (willDisconnect)
            {
                color = UnitConnectionStyles.disconnectColor;
            }
            else if (highlight)
            {
                color = UnitConnectionStyles.highlightColor;
            }
            else if (colorIfActive)
            {
                if (EditorApplication.isPaused)
                {
                    if (EditorTimeBinding.frame == ConnectionDebugData.lastInvokeFrame)
                    {
                        color = UnitConnectionStyles.activeColor;
                    }
                }
                else
                {
                    color = Color.Lerp(UnitConnectionStyles.activeColor, color, (EditorTimeBinding.time - ConnectionDebugData.lastInvokeTime) / UnitWidget<IUnit>.Styles.invokeFadeDuration);
                }
            }

            var thickness = 3;

            GraphGUI.DrawConnection(color, sourceHandleEdgeCenter, destinationHandleEdgeCenter, Edge.Right, Edge.Left, null, Vector2.zero, UnitConnectionStyles.relativeBend, UnitConnectionStyles.minBend, thickness);
        }

        #endregion


        #region Selecting

        public override bool canSelect => false;

        #endregion


        #region Dragging

        public override bool canDrag => false;

        #endregion


        #region Deleting

        public override bool canDelete => true;

        #endregion


        #region Droplets

        private readonly List<float> droplets = new List<float>();

        private float dropTime;

        private float lastInvokeTime;

        private const float handleAlignmentMargin = 0.1f;

        protected virtual bool showDroplets => true;

        protected abstract Vector2 GetDropletSize();

        protected abstract void DrawDroplet(Rect position);

        protected virtual void DrawDroplets()
        {
            foreach (var droplet in droplets)
            {
                Vector2 position;

                if (droplet < handleAlignmentMargin)
                {
                    var t = droplet / handleAlignmentMargin;
                    position = Vector2.Lerp(sourceHandlePosition.center, sourceHandleEdgeCenter, t);
                }
                else if (droplet > 1 - handleAlignmentMargin)
                {
                    var t = (droplet - (1 - handleAlignmentMargin)) / handleAlignmentMargin;
                    position = Vector2.Lerp(destinationHandleEdgeCenter, destinationHandlePosition.center, t);
                }
                else
                {
                    var t = (droplet - handleAlignmentMargin) / (1 - 2 * handleAlignmentMargin);
                    position = GraphGUI.GetPointOnConnection(t, sourceHandleEdgeCenter, destinationHandleEdgeCenter, Edge.Right, Edge.Left, UnitConnectionStyles.relativeBend, UnitConnectionStyles.minBend);
                }

                var size = GetDropletSize();

                using (LudiqGUI.color.Override(GUI.color * color))
                {
                    DrawDroplet(new Rect(position.x - size.x / 2, position.y - size.y / 2, size.x, size.y));
                }
            }
        }

        #endregion
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    using System;
using UnityEditor;
using UnityEngine;

namespace Unity.VisualScripting
{
    [Widget(typeof(ValueConnection))]
    public sealed class ValueConnectionWidget : UnitConnectionWidget<ValueConnection>
    {
        public ValueConnectionWidget(FlowCanvas canvas, ValueConnection connection) : base(canvas, connection) { }

        private new ValueConnection.DebugData ConnectionDebugData => GetDebugData<ValueConnection.DebugData>();


        #region Drawing

        public override Color color => DetermineColor(connection.source.type, connection.destination.type);

        protected override bool colorIfActive => !BoltFlow.Configuration.animateControlConnections || !BoltFlow.Configuration.animateValueConnections;

        public override void DrawForeground()
        {
            base.DrawForeground();

            if (BoltFlow.Configuration.showConnectionValues)
            {
                var showLastValue = EditorApplication.isPlaying && ConnectionDebugData.assignedLastValue;
                var showPredictedvalue = BoltFlow.Configuration.predictConnectionValues && !EditorApplication.isPlaying && Flow.CanPredict(connection.source, reference);

                if (showLastValue || showPredictedvalue)
                {
                    var previousIconSize = EditorGUIUtility.GetIconSize();
                    EditorGUIUtility.SetIconSize(new Vector2(IconSize.Small, IconSize.Small));

                    object value;

                    if (showLastValue)
                    {
                        value = ConnectionDebugData.lastValue;
                    }
                    else // if (showPredictedvalue)
                    {
                        value = Flow.Predict(connection.source, reference);
                    }

                    var label = new GUIContent(value.ToShortString(), Icons.Type(value?.GetType())?[IconSize.Small]);
                    var labelSize = Styles.prediction.CalcSize(label);
                    var labelPosition = new Rect(position.position - labelSize / 2, labelSize);

                    BeginDim();

                    GUI.Label(labelPosition, label, Styles.prediction);

                    EndDim();

                    EditorGUIUtility.SetIconSize(previousIconSize);
                }
            }
        }

        public static Color DetermineColor(Type source, Type destination)
        {
            if (destination == typeof(object))
            {
                return DetermineColor(source);
            }

            return DetermineColor(destination);
        }

        public static Color DetermineColor(Type type)
        {
            if (type == null)
            {
                return new Color(0.8f, 0.8f, 0.8f);
            }

            if (type == typeof(string))
            {
                return new Color(1.0f, 0.62f, 0.35f);
            }

            if (type == typeof(bool))
            {
                return new Color(0.86f, 0.55f, 0.92f);
            }

            if (type == typeof(char))
            {
                return new Color(1.0f, 0.90f, 0.40f);
            }

            if (type.IsEnum)
            {
                return new Color(1.0f, 0.63f, 0.66f);
            }

            if (type.IsNumeric())
            {
                return new Color(0.45f, 0.78f, 1f);
            }

            if (type.IsNumericConstruct())
            {
                return new Color(0.45f, 1.00f, 0.82f);
            }

            return new Color(0.60f, 0.88f, 0.00f);
        }

        #endregion


        #region Droplets

        protected override bool showDroplets => BoltFlow.Configuration.animateValueConnections;

        protected override Vector2 GetDropletSize()
        {
            return BoltFlow.Icons.valuePortConnected?[12].Size() ?? 12 * Vector3.one;
        }

        protected override void DrawDroplet(Rect position)
        {
            if (BoltFlow.Icons.valuePortConnected != null)
            {
                GUI.DrawTexture(position, BoltFlow.Icons.valuePortConnected?[12]);
            }
        }

        #endregion


        private static class Styles
        {
            static Styles()
            {
                prediction = new GUIStyle(EditorStyles.label);
                prediction.normal.textColor = Color.white;
                prediction.fontSize = 9;
                prediction.normal.background = new Color(0, 0, 0, 0.25f).GetPixel();
                prediction.padding = new RectOffset(4, 6, 3, 3);
                prediction.margin = new RectOffset(0, 0, 0, 0);
                prediction.alignment = TextAnchor.MiddleCenter;
            }

            public static readonly GUIStyle prediction;
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          INDX( 	 ªÏ:           (   8
  è       ÙÙ                  ›{    € n     ”    ;]çìÙ0`íù¯Ù‹bçìÙ3rË$èìÙø       ÷                F l o w G r a p h D e s c r i p t o r . c s . ”    ˆ x     ”    şäWÀìÙ P›î‚¤Ù`Ğ†ÀäÙùWÀìÙø       ó                F l o w G r a p h D e s c r i p t o r . c s . m e t a –{    ˆ r     ”    @\çìÙ0`íù¯Ùn]çìÙKË$èìÙ                     F l o w M a c h i n e D e s c r i p t o r . c s . m e ”     |     ”    ÿ»WÀìÙ P›î‚¤ÙaÍ†Àä ÿ»WÀìÙø       ó                F l o w M a c h i n e D e s c r i p t o r . c s . m e t a     š{    € n     ”    eı\çìÙ0`íù¯Ù=u^çìÙç¬Ë$èìÙ                     F l o w M a c r o D e s c r i p t o r . c s . 	”    ˆ x     ”    ’‘WÀìÙ P›î‚¤ÙåËÊ†ÀäÙ’‘WÀìÙø       ó                F l o w M a c r o D e s c r i p t o r . c s . m e t a œ{    x f     ”    –g]çìÙ€#îù¯Ù‹bçìÙD™Ë$èìÙ¨      §               I U n i t D e s c r i p t o r . c s . ”    € p     ”    >d’WÀì  P›î‚¤ÙcèÈ†ÀäÙ>d’WÀìÙø       ó                I U n i t D e s c r i p t o r . c s . m e t a ”    p `     ”    'µ’WÀìÙ P›î‚¤ÙİØÇ†ÀäÙ¬Ü’WÀìÙ @      Ã1               U n i t A n a l y s e r . c s ”    € j     ”    *“WÀìÙ P›î‚¤Ù7,Æ†ÀäÙ*“WÀìÙø       ó                U n i t A n a l y s e r . c s . m e t a       {    p `     ”    òØ]çìÙĞæîù¯Ù‹bçìÙ3rË$èìÙ˜       ˜                U n i t A n a l y s i s . c s ”    € j     ”    ±è“WÀìÙ P›î‚¤Ùm+Ä†ÀäÙ¸”WÀìÙø      ó                U n i t A n a l y s i s . c s . m e t a       {    x f     ”    òØ]çìÙĞæîù¯Ù‹bçìÙKË$èìÙ0      .               U n i t D e s c r i p t i o n . c s . ”    € p     ”    ÓÍ”WÀìÙ P›î‚¤ÙSüÁ†ÀäÙÓÍ”WÀìÙø       ó                U n i t D e s c r i p t i o n . c s . m e t a ”    x d     ”    ´•WÀìÙ P›î‚¤Ù›Á†ÀäÙ´•WÀìÙ @      *1               U n i t D e s c r i p t o r . c s     ”    € n     ”    ´w•WÀìÙ P›î‚¤Ùr6¿†ÀäÙ¹•WÀìÙø       ó               U n i t D e s c r i p t o r . c s . m e t a   Ÿ{    € n     ”    òØ]çìÙƒïù¯Ù‹bçìÙç¬Ë$èìÙ       ß               U n i t P o r t D e s c r i p t i o n . c s . ”    ˆ x     ”    ÎV–WÀìÙ P›î‚¤Ù4Œ¼†ÀäÙÎV–WÀìÙø       ó                U n i t P o r t D e s c r i p t i o n . c s . m e t a ¡{    € l     ”    À²^çìÙ ªïù¯Ù‹bçìÙç¬Ë$èìÙ       ß               U n i t P o r t D e s c r i p t o r . c s . m ”    ˆ v     ”    ]—WÀìÙ P›î‚¤ÙFº†ÀäÙb*—WÀìÙø       ó               U n i t P o r t D e s c r i p t o r . c s . m e t a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Unity.VisualScripting
{
    [Analyser(typeof(IUnit))]
    public class UnitAnalyser<TUnit> : Analyser<TUnit, UnitAnalysis>
        where TUnit : class, IUnit
    {
        public UnitAnalyser(GraphReference reference, TUnit target) : base(reference, target) { }

        public TUnit unit => target;

        [Assigns]
        protected bool IsEntered()
        {
            using (var recursion = Recursion.New(1))
            {
                return IsEntered(unit, recursion);
            }
        }

        private static bool IsEntered(IUnit unit, Recursion recursion)
        {
            if (unit.isControlRoot)
            {
                return true;
            }

            foreach (var controlInput in unit.controlInputs)
            {
                if (!controlInput.isPredictable || controlInput.couldBeEntered)
                {
                    return true;
                }
            }

            foreach (var valueOutput in unit.valueOutputs)
            {
                if (!recursion?.TryEnter(valueOutput) ?? false)
                {
                    continue;
                }

                var valueOutputEntered = valueOutput.validConnections.Any(c => IsEntered(c.destination.unit, recursion));

                recursion?.Exit(valueOutput);

                if (valueOutputEntered)
                {
                    return true;
                }
            }

            return false;
        }

        private string PortLabel(IUnitPort port)
        {
            return port.Description<UnitPortDescription>().label;
        }

        [Assigns]
        protected virtual IEnumerable<Warning> Warnings()
        {
            var isEntered = IsEntered();

            if (!unit.isDefined)
            {
                if (unit.definitionException != null)
                {
                    yield return Warning.Exception(unit.definitionException);
                }
                else if (!unit.canDefine)
                {
                    yield return Warning.Caution("Node is not properly configured.");
                }
            }
            else if (unit is MissingType)
            {
                var formerType = $"{(unit as MissingType)?.formerType}";
                formerType = string.IsNullOrEmpty(formerType) ? string.Empty : $"'{formerType}'";
                yield return new ActionButtonWarning(
                    WarningLevel.Error,
                    $"The source script for this node type can't be found. Did you remove its script?\n" +
                    $"Replace the node or add the {formerType} script file back to your project files.",
                    "Replace Node",
                    () =>
                    { UnitWidgetHelper.ReplaceUnit(unit, reference, context, context.selection, new EventWrapper(unit)); }
                );
                yield break;
            }

            if (!isEntered)
            {
                yield return Warning.Info("Node is never entered.");
            }

            // Obsolete attribute is not inherited, so traverse the chain manually
            var obsoleteAttribute = unit.GetType().AndHierarchy().FirstOrDefault(t => t.HasAttribute<ObsoleteAttribute>())?.GetAttribute<ObsoleteAttribute>();

            if (obsoleteAttribute != null)
            {
                var unitName = BoltFlowNameUtility.UnitTitle(unit.GetType(), true, false);

                if (obsoleteAttribute.Message != null)
                {
                    Debug.LogWarning($"\"{unitName}\" node is deprecated: {obsoleteAttribute.Message}");
                    yield return Warning.Caution($"Deprecated: {obsoleteAttribute.Message}");
                }
                else
                {
                    Debug.LogWarning($"\"{unitName}\" node is deprecated.");
                    yield return Warning.Caution("This node is deprecated.");
                }
            }

            if (unit.isDefined)
            {
                foreach (var invalidInput in unit.invalidInputs)
                {
                    yield return Warning.Caution($"{PortLabel(invalidInput)} is not used by this unit.");
                }

                foreach (var invalidOutput in unit.invalidOutputs)
                {
                    yield return Warning.Caution($"{PortLabel(invalidOutput)} is not provided by this unit.");
                }

                foreach (var validPort in unit.validPorts)
                {
                    if (validPort.hasInvalidConnection)
                    {
                        yield return Warning.Caution($"{PortLabel(validPort)} has an invalid connection.");
                    }
                }

#if UNITY_IOS || UNITY_ANDROID || UNITY_TVOS
                if (unit is IMouseEventUnit)
                {
                    var graphName = string.IsNullOrEmpty(unit.graph.title) ? "A ScriptGraph" : $"The ScriptGraph {unit.graph.title}";
                    var unitName = BoltFlowNameUtility.UnitTitle(unit.GetType(), true, false);
                    Debug.LogWarning($"{graphName} contains a {unitName} node. Presence of MouseEvent nodes might impact performance on handheld devices.");
                    yield return Warning.Caution("Presence of MouseEvent nodes might impact performance on handheld devices.");
                }
#endif
            }

            foreach (var controlInput in unit.controlInputs)
            {
                if (!controlInput.hasValidConnection)
                {
                    continue;
                }

                foreach (var relation in controlInput.relations)
                {
                    if (relation.source is ValueInput)
                    {
                        var valueInput = (ValueInput)relation.source;

                        foreach (var warning in ValueInputWarnings(valueInput))
                        {
                            yield return warning;
                        }
                    }
                }
            }

            foreach (var controlOutput in unit.controlOutputs)
            {
                if (!controlOutput.hasValidConnection)
                {
                    continue;
                }

                var controlInputs = controlOutput.relations.Select(r => r.source).OfType<ControlInput>();

                var isTriggered = !controlInputs.Any() || controlInputs.Any(ci => !ci.isPredictable || ci.couldBeEntered);

                foreach (var relation in controlOutput.relations)
                {
                    if (relation.source is ValueInput)
                    {
                        var valueInput = (ValueInput)relation.source;

                        foreach (var warning in ValueInputWarnings(valueInput))
                        {
                            yield return warning;
                        }
                    }
                }

                if (isEntered && !isTriggered)
                {
                    yield return Warning.Caution($"{PortLabel(controlOutput)} is connected, but it is never triggered.");
                }
            }

            foreach (var valueOutput in unit.valueOutputs)
            {
                if (!valueOutput.hasValidConnection)
                {
                    continue;
                }

                foreach (var relation in valueOutput.relations)
                {
                    if (relation.source is ControlInput)
                    {
                        var controlInput = (ControlInput)relation.source;

                        if (isEntered && controlInput.isPredictable && !controlInput.couldBeEntered)
                        {
                            yield return Warning.Severe($"{PortLabel(controlInput)} is required, but it is never entered.");
                        }
                    }
                    else if (relation.source is ValueInput)
                    {
                        var valueInput = (ValueInput)relation.source;

                        foreach (var warning in ValueInputWarnings(valueInput))
                        {
                            yield return warning;
                        }
                    }
                }
            }
        }

        private IEnumerable<Warning> ValueInputWarnings(ValueInput valueInput)
        {
            // We can disable null reference check if no self is available
            // and the port requires an owner, for example in macros.
            var trustFutureOwner = valueInput.nullMeansSelf && reference.self == null;

            var checkForNullReference = BoltFlow.Configuration.predictPotentialNullReferences && !valueInput.allowsNull && !trustFutureOwner;

            var checkForMissingComponent = BoltFlow.Configuration.predictPotentialMissingComponents && typeof(Component).IsAssignableFrom(valueInput.type);

            // Note that we cannot directly check the input's predicted value, because it
            // will return false for safeguard specifically because it might be missing requirements.
            // Therefore, we first check the connected value, then the default value.

            // If the port is connected to a predictable output, use the connected value to perform checks.
            if (valueInput.hasValidConnection)
            {
                var valueOutput = valueInput.validConnectedPorts.Single();

                if (Flow.CanPredict(valueOutput, reference))
                {
                    if (checkForNullReference)
                    {
                        if (Flow.Predict(valueOutput, reference) == null)
                        {
                            yield return Warning.Severe($"{PortLabel(valueInput)} cannot be null.");
                        }
                    }

                    if (checkForMissingComponent)
                    {
                        var connectedPredictedValue = Flow.Predict(valueOutput, reference);

                        // This check is necessary, because the predicted value could be
                        // incompatible as connections with non-guaranteed conversions are allowed.
                        if (ConversionUtility.CanConvert(connectedPredictedValue, typeof(GameObject), true))
                        {
                            var gameObject = ConversionUtility.Convert<GameObject>(connectedPredictedValue);

                            if (gameObject != null)
                            {
                                var component = (Component)ConversionUtility.Convert(gameObject, valueInput.type);

                                if (component == null)
                                {
                                    yield return Warning.Caution($"{PortLabel(valueInput)} is missing a {valueInput.type.DisplayName()} component.");
                                }
                            }
                        }
                    }
                }
            }
            // If the port isn't connected but has a default value, use the default value to perform checks.
            else if (valueInput.hasDefaultValue)
            {
                if (checkForNullReference)
                {
                    if (Flow.Predict(valueInput, reference) == null)
                    {
                        yield return Warning.Severe($"{PortLabel(valueInput)} cannot be null.");
                    }
                }

                if (checkForMissingComponent)
                {
                    var unconnectedPredictedValue = Flow.Predict(valueInput, reference);

                    if (ConversionUtility.CanConvert(unconnectedPredictedValue, typeof(GameObject), true))
                    {
                        var gameObject = ConversionUtility.Convert<GameObject>(unconnectedPredictedValue);

                        if (gameObject != null)
                        {
                            var component = (Component)ConversionUtility.Convert(gameObject, valueInput.type);

                            if (component == null)
                            {
                                yield return Warning.Caution($"{PortLabel(valueInput)} is missing a {valueInput.type.DisplayName()} component.");
                            }
                        }
                    }
                }
            }
            // The value isn't connected and has no default value,
            // therefore it is certain to be missing at runtime.
            else
            {
                yield return Warning.Severe($"{PortLabel(valueInput)} is missing.");
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityObject = UnityEngine.Object;

namespace Unity.VisualScripting
{
    [Descriptor(typeof(IUnit))]
    public class UnitDescriptor<TUnit> : Descriptor<TUnit, UnitDescription>, IUnitDescriptor
        where TUnit : class, IUnit
    {
        public UnitDescriptor(TUnit target) : base(target)
        {
            unitType = unit.GetType();
        }

        protected Type unitType { get; }

        public TUnit unit => target;

        IUnit IUnitDescriptor.unit => unit;

        private enum State
        {
            Defined,

            NotDefined,

            FailedToDefine
        }

        private State state
        {
            get
            {
                if (unit.isDefined)
                {
                    return State.Defined;
                }
                else if (unit.failedToDefine)
                {
                    return State.FailedToDefine;
                }
                else
                {
                    return State.NotDefined;
                }
            }
        }


        #region Reflected Description

        static UnitDescriptor()
        {
            XmlDocumentation.loadComplete += FreeReflectedDescriptions;
        }

        public static void FreeReflectedDescriptions()
        {
            reflectedDescriptions.Clear();
            reflectedInputDescriptions.Clear();
            reflectedOutputDescriptions.Clear();
        }

        protected UnitDescription reflectedDescription
        {
            get
            {
                if (!reflectedDescriptions.TryGetValue(unitType, out var reflectedDescription))
                {
                    reflectedDescription = FetchReflectedDescription(unitType);
                    reflectedDescriptions.Add(unitType, reflectedDescription);
                }

                return reflectedDescription;
            }
        }

        protected UnitPortDescription ReflectedPortDescription(IUnitPort port)
        {
            if (port is IUnitInvalidPort)
            {
                return null;
            }

            if (port is IUnitInputPort)
            {
                if (!reflectedInputDescriptions.TryGetValue(unitType, out var _reflectedInputDescriptions))
                {
                    _reflectedInputDescriptions = FetchReflectedPortDescriptions<IUnitInputPort>(unitType);
                    reflectedInputDescriptions.Add(unitType, _reflectedInputDescriptions);
                }

                if (_reflectedInputDescriptions.TryGetValue(port.key, out var portDescription))
                {
                    return portDescription;
                }
            }
            else if (port is IUnitOutputPort)
            {
                if (!reflectedOutputDescriptions.TryGetValue(unitType, out var _reflectedOutputDescriptions))
                {
                    _reflectedOutputDescriptions = FetchReflectedPortDescriptions<IUnitOutputPort>(unitType);
                    reflectedOutputDescriptions.Add(unitType, _reflectedOutputDescriptions);
                }

                if (_reflectedOutputDescriptions.TryGetValue(port.key, out var portDescription))
                {
                    return portDescription;
                }
            }

            return null;
        }

        private static readonly Dictionary<Type, UnitDescription> reflectedDescriptions = new Dictionary<Type, UnitDescription>();

        private static readonly Dictionary<Type, Dictionary<string, UnitPortDescription>> reflectedInputDescriptions = new Dictionary<Type, Dictionary<string, UnitPortDescription>>();

        private static readonly Dictionary<Type, Dictionary<string, UnitPortDescription>> reflectedOutputDescriptions = new Dictionary<Type, Dictionary<string, UnitPortDescription>>();

        private static UnitDescription FetchReflectedDescription(Type unitType)
        {
            var oldName = BoltFlowNameUtility.UnitPreviousTitle(unitType);
            var prefix = string.IsNullOrEmpty(oldName) ? string.Empty : $"(Previously named {oldName}) ";

            return new UnitDescription()
            {
                title = BoltFlowNameUtility.UnitTitle(unitType, false, true),
                shortTitle = BoltFlowNameUtility.UnitTitle(unitType, true, true),
                surtitle = unitType.GetAttribute<UnitSurtitleAttribute>()?.surtitle,
                subtitle = unitType.GetAttribute<UnitSubtitleAttribute>()?.subtitle,
                summary = prefix + unitType.Summary()
            };
        }

        private static Dictionary<string, UnitPortDescription> FetchReflectedPortDescriptions<T>(Type unitType) where T : IUnitPort
        {
            var descriptions = new Dictionary<string, UnitPortDescription>();

            foreach (var portMember in unitType.GetMembers().Where(member => typeof(T).IsAssignableFrom(member.GetAccessorType())))
            {
                var key = portMember.GetAttribute<PortKeyAttribute>()?.key ?? portMember.Name;

                if (descriptions.ContainsKey(key))
                {
                    Debug.LogWarning("Duplicate reflected port description for: " + key);

                    continue;
                }

                descriptions.Add(key, FetchReflectedPortDescription(portMember));
            }

            return descriptions;
        }

        private static UnitPortDescription FetchReflectedPortDescription(MemberInfo portMember)
        {
            return new UnitPortDescription()
            {
                label = portMember.GetAttribute<PortLabelAttribute>()?.label ?? portMember.HumanName(),
                showLabel = !(portMember.HasAttribute<PortLabelHiddenAttribute>() || (portMember.GetAttribute<PortLabelAttribute>()?.hidden ?? false)),
                summary = portMember.Summary(),
                getMetadata = (unitMetadata) => unitMetadata[portMember.Name]
            };
        }

        #endregion


        #region Description

        [Assigns]
        public sealed override string Title()
        {
            switch (state)
            {
                case State.Defined: return DefinedTitle();
                case State.NotDefined: return DefaultTitle();
                case State.FailedToDefine: return ErrorTitle(unit.definitionException);
                default: throw new UnexpectedEnumValueException<State>(state);
            }
        }

        [Assigns]
        public string ShortTitle()
        {
            switch (state)
            {
                case State.Defined: return DefinedShortTitle();
                case State.NotDefined: return DefaultShortTitle();
                case State.FailedToDefine: return ErrorShortTitle(unit.definitionException);
                default: throw new UnexpectedEnumValueException<State>(state);
            }
        }

        [Assigns]
        public string Surtitle()
        {
            switch (state)
            {
                case State.Defined: return DefinedSurtitle();
                case State.NotDefined: return DefaultSurtitle();
                case State.FailedToDefine: return ErrorSurtitle(unit.definitionException);
                default: throw new UnexpectedEnumValueException<State>(state);
            }
        }

        [Assigns]
        public string Subtitle()
        {
            switch (state)
            {
                case State.Defined: return DefinedSubtitle();
                case State.NotDefined: return DefaultSubtitle();
                case State.FailedToDefine: return ErrorSubtitle(unit.definitionException);
                default: throw new UnexpectedEnumValueException<State>(state);
            }
        }

        [Assigns]
        public sealed override string Summary()
        {
            switch (state)
            {
                case State.Defined: return DefinedSummary();
                case State.NotDefined: return DefaultSummary();
                case State.FailedToDefine: return ErrorSummary(unit.definitionException);
                default: throw new UnexpectedEnumValueException<State>(state);
            }
        }

        [Assigns]
        [RequiresUnityAPI]
        public sealed override EditorTexture Icon()
        {
            switch (state)
            {
                case State.Defined: return DefinedIcon();
                case State.NotDefined: return DefaultIcon();
                case State.FailedToDefine: return ErrorIcon(unit.definitionException);
                default: throw new UnexpectedEnumValueException<State>(state);
            }
        }

        [Assigns]
        [RequiresUnityAPI]
        public IEnumerable<EditorTexture> Icons()
        {
            switch (state)
            {
                case State.Defined: return DefinedIcons();
                case State.NotDefined: return DefaultIcons();
                case State.FailedToDefine: return ErrorIcons(unit.definitionException);
                default: throw new UnexpectedEnumValueException<State>(state);
            }
        }

        protected virtual string DefinedTitle()
        {
            return reflectedDescription.title;
        }

        protected virtual string DefaultTitle()
        {
            return reflectedDescription.title;
        }

        protected virtual string ErrorTitle(Exception exception)
        {
            return reflectedDescription.title;
        }

        protected virtual string DefinedShortTitle()
        {
            return reflectedDescription.shortTitle;
        }

        protected virtual string DefaultShortTitle()
        {
            return reflectedDescription.shortTitle;
        }

        protected virtual string ErrorShortTitle(Exception exception)
        {
            return ErrorTitle(exception);
        }

        protected virtual string DefinedSurtitle()
        {
            return reflectedDescription.surtitle;
        }

        protected virtual string DefaultSurtitle()
        {
            return reflectedDescription.surtitle;
        }

        protected virtual string ErrorSurtitle(Exception exception)
        {
            return null;
        }

        protected virtual string DefinedSubtitle()
        {
            return reflectedDescription.subtitle;
        }

        protected virtual string DefaultSubtitle()
        {
            return reflectedDescription.subtitle;
        }

        protected virtual string ErrorSubtitle(Exception exception)
        {
            return null;
        }

        protected virtual string DefinedSummary()
        {
            return reflectedDescription.summary;
        }

        protected virtual string DefaultSummary()
        {
            return reflectedDescription.summary;
        }

        protected virtual string ErrorSummary(Exception exception)
        {
            return $"This node failed to define.\n\n{exception.DisplayName()}: {exception.Message}";
        }

        protected virtual EditorTexture DefinedIcon()
        {
            return unit.GetType().Icon();
        }

        protected virtual EditorTexture DefaultIcon()
        {
            return unit.GetType().Icon();
        }

        protected virtual EditorTexture ErrorIcon(Exception exception)
        {
            return BoltCore.Icons.errorState;
        }

        protected virtual IEnumerable<EditorTexture> DefinedIcons()
        {
            return Enumerable.Empty<EditorTexture>();
        }

        protected virtual IEnumerable<EditorTexture> DefaultIcons()
        {
            return Enumerable.Empty<EditorTexture>();
        }

        protected virtual IEnumerable<EditorTexture> ErrorIcons(Exception exception)
        {
            return Enumerable.Empty<EditorTexture>();
        }

        public void DescribePort(IUnitPort port, UnitPortDescription description)
        {
            description.getMetadata = (unitMetadata) => unitMetadata.StaticObject(port);

            // Only defined nodes can have specific ports
            if (state == State.Defined)
            {
                DefinedPort(port, description);
            }
        }

        protected virtual void DefinedPort(IUnitPort port, UnitPortDescription description)
        {
            var reflectedPortDescription = ReflectedPortDescription(port);

            if (reflectedPortDescription != null)
            {
                description.CopyFrom(reflectedPortDescription);
            }
        }

        #endregion
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      using System;

using UnityEngine;

namespace Unity.PlasticSCM.Editor.UI
{
    internal class EditorVersion
    {
        internal int Year;
        internal int Release;
        internal int Update;

        EditorVersion(int year, int release, int update)
        {
            Year = year;
            Release = release;
            Update = update;
        }


        public override string ToString()
        {
            return String.Format("{0}.{1}.{2}", Year, Release, Update);
        }

        internal static bool IsCurrentEditorOlderThan(string version)
        {
            return IsEditorOlderThan(Application.unityVersion, version);
        }

        internal static bool IsEditorOlderThan(string versionA, string versionB)
        {
#if UNITY_2017_1_OR_NEWER
            var editorA = Parse(versionA);
            var editorB = Parse(versionB);
            if (editorA.Year == editorB.Year)
            {
                if (editorA.Release == editorB.Release)
                {
                    return editorA.Update < editorB.Update;
                }
                return editorA.Release < editorB.Release;
            }
            return editorA.Year < editorB.Year;
#else
            return false;
#endif
        }

        static int ParseUpdateString(string version)
        {
            int pos = 0;
            char[] characters = version.ToCharArray();
            while (Char.IsDigit(characters[pos]))
            {
                ++pos;
            }
            return int.Parse(version.Substring(0, pos));
        }

        static EditorVersion Parse(string version)
        {
            var versions = version.Split('.');

            var year = 0;
            year = int.Parse(versions[0]);
            var release = 0;
            release = int.Parse(versions[1]);
            var update = 0;
            update = ParseUpdateString(versions[2]);

            return new EditorVersion(year, release, update);
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ï»¿using Codice.Utils;
using PlasticGui;

namespace Unity.PlasticSCM.Editor.UI
{
    internal static class GetPlasticShortcut
    {
        internal static string ForOpen()
        {
            return PlasticLocalization.GetString(
                PlasticLocalization.Name.UnityOpenShortcut);
        }

        internal static string ForDelete()
        {
            if (PlatformIdentifier.IsWindows())
                return PlasticLocalization.GetString(
                    PlasticLocalization.Name.UnityDeleteShortcutForWindows);

            if (PlatformIdentifier.IsMac())
                return PlasticLocalization.GetString(
                    PlasticLocalization.Name.UnityDeleteShortcutForMacOS);

            return string.Empty;
        }

        internal static string ForDiff()
        {
            return PlasticLocalization.GetString(
                PlasticLocalization.Name.UnityDiffShortcut);
        }

        internal static string ForAssetDiff()
        {
            return PlasticLocalization.GetString(
                PlasticLocalization.Name.UnityAssetDiffShortcut);
        }

        internal static string ForHistory()
        {
            if (PlatformIdentifier.IsWindows())
                return PlasticLocalization.GetString(
                    PlasticLocalization.Name.UnityHistoryShortcutForWindows);

            if (PlatformIdentifier.IsMac())
                return PlasticLocalization.GetString(
                    PlasticLocalization.Name.UnityHistoryShortcutForMacOS);

            return string.Empty;
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           INDX( 	 HÛ:           (   À  è       Ù t                  {    ˆ r     ”    Æ'^çìÙ`Fğù¯Ù‹bçìÙ3rË$èìÙ°      ©               C u s t o m E v e n t D e s c r i p t o r . c s . m e ”     |     ”    p%˜WÀìÙ P›î‚¤ÙZU¶†ÀäÙwL˜WÀìÙø       ó                C u s t o m E v e n t D e s c r i p t o r . c s . m e t a     £{    € n     ”    À²^çìÙ`Fğù¯Ù‹bçìÙKË$èìÙ`      ^               E v e n t U n i t D e s c r i p t o r . c s . ”    ˆ x     ”    '™WÀìÙ P›î‚¤ YÇ³†ÀäÙ'™WÀìÙø       ó                E v e n t U n i t D e s c r i p t o r . c s . m e t a ¢{    x f     ”    À²^çìÙ`Fğù¯Ù‹bçìÙç¬Ë$èìÙ8      5               E v e n t U n i t W i d g e t . c s . ”    € p     ”    °™WÀìÙ P›î‚¤ÙèË±†ÀäÙ×™WÀìÙø       ó                E v e n t U n i t W i d g e t . c s . m e t a ¤{     ~     ”    È_çìÙ°	ñù¯Ù‹bçìÙç¬Ë$èìÙˆ                     G l o b a l M e s s a g e L i s t e n e r E d i t o r . c s .  ”    ˜ ˆ     ”    g…šWÀìÙ P›î‚¤ÙsÒ¯†ÀäÙl¬šWÀìÙø       ó               # G l o b a l M e s s a g e L i s t e n e r E d i t o r . c s . m e t a ¦{    ˆ r     ”    Óv_çìÙğ¥ñù¯Ù‹bçìÙ3rË$èìÙx      u               M e s s a g e L i s t e n e r E d i t o r . c s . m e "”     |     ”    b›WÀìÙ P›î‚¤Ùsµ­†ÀäÙb›WÀìÙø       ó                M e s s a g e L i s t e n e r E d i t o r . c s . m e t a     ¥{     €     ”    È_çìÙğ¥ñù¯Ùø=bçìÙKË$èìÙh      b               T r i g g e r C u s  o m E v e n t D e s c r i p t o r . c s $”      Š     ”    àœWÀìÙ P›î‚¤Ù«†ÀäÙ•4œWÀìÙø       ó               $ T r i g g e r C u s t o m E v e n t D e